# 实现exec

`exec` 函数的作用是用新的可执行文件替换当前进程的程序体。具体来说，`exec` 会将当前正在运行的用户进程的进程体（包括代码段、数据段、堆、栈等）替换为一个新的可执行文件的进程体。这样，新的程序会接管当前进程的地址空间，继续执行新程序的代码，但该进程的 PID（进程ID）保持不变。也就是说，执行 `exec` 后，原来进程的地址空间被清除，并且新程序的内容会加载到同样的进程中，继续执行。

为什么需要实现 `exec` 呢？这个问题的答案与 shell 的工作方式密切相关。在实现一些简单的命令时，我们使用了类似 `if-else if` 的结构来判断并执行不同的命令。然而，这种方法存在很大的局限性。首先，它无法处理用户输入的新命令，因为我们不能预见到用户会输入什么命令，且每添加一个新命令就需要修改代码并重新编译。这种方式不仅繁琐，而且无法应对外部程序的运行。

`exec` 的实现解决了这个问题。当 `exec` 被调用时，它允许用户运行外部程序，而不需要修改 shell 本身的代码。用户输入的命令会被解析，且通过 `exec` 函数加载并执行对应的外部程序，从而提供了更灵活的命令执行方式。

`exec` 是一个函数簇，包含多个相关的函数，区别主要在于如何表示程序对象以及是否传入环境变量。例如，`execv` 函数就不需要传入环境变量，但其他 `exec` 函数可能会接受额外的环境变量。

当调用 `execv` 时，如果执行成功，进程将直接跳转到新程序，并不会返回，因此它没有返回值。调用 `execv` 失败时，它会返回 `-1`，并设置错误码。这是因为 `exec` 执行新程序时，原进程的执行流被完全替换，进程不会再回到原来的位置，因而不需要像传统函数那样返回值。

## 建立抽象

​	我们先对exe文件做抽象：

```
extern void intr_exit(void);
typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;
typedef uint16_t Elf32_Half;

/* 32-bit ELF header */
struct Elf32_Ehdr {
    unsigned char e_ident[16]; // ELF identification bytes
    Elf32_Half e_type;         // Type of file (e.g., executable)
    Elf32_Half e_machine;      // Machine architecture
    Elf32_Word e_version;      // ELF version
    Elf32_Addr e_entry;        // Entry point address
    Elf32_Off e_phoff;         // Program header offset
    Elf32_Off e_shoff;         // Section header offset
    Elf32_Word e_flags;        // Processor-specific flags
    Elf32_Half e_ehsize;       // ELF header size
    Elf32_Half e_phentsize;    // Program header entry size
    Elf32_Half e_phnum;        // Number of program headers
    Elf32_Half e_shentsize;    // Section header entry size
    Elf32_Half e_shnum;        // Number of section headers
    Elf32_Half e_shstrndx;     // Section header string table index
};

/* Program header (segment descriptor) */
struct Elf32_Phdr {
    Elf32_Word p_type;   // Segment type (e.g., PT_LOAD)
    Elf32_Off p_offset;  // Offset in file
    Elf32_Addr p_vaddr;  // Virtual address in memory
    Elf32_Addr p_paddr;  // Physical address (unused)
    Elf32_Word p_filesz; // Size of segment in file
    Elf32_Word p_memsz;  // Size of segment in memory
    Elf32_Word p_flags;  // Segment flags
    Elf32_Word p_align;  // Segment alignment
};

/* Segment types */
enum segment_type {
    PT_NULL,    // Ignore segment
    PT_LOAD,    // Loadable segment
    PT_DYNAMIC, // Dynamic loading information
    PT_INTERP,  // Name of dynamic loader
    PT_NOTE,    // Auxiliary information
    PT_SHLIB,   // Reserved
    PT_PHDR     // Program header
};
```

这段代码定义了32位ELF（Executable and Linkable Format）格式的结构体以及相关的常量，用于描述ELF文件的头部和程序段的描述。具体来说，主要包括以下内容：

1. **Elf32_Ehdr**: 该结构体表示ELF文件的头部，包含了ELF文件的基本信息，如文件标识、类型、机器架构、入口地址、程序头的偏移量等。具体字段的含义如下：
   - `e_ident`：ELF文件标识字节，用于标识文件类型和版本。
   - `e_type`：文件类型，表明ELF文件是可执行文件、共享库文件还是其他类型。
   - `e_machine`：表示机器架构的字段，如x86、ARM等。
   - `e_version`：ELF版本，通常为1。
   - `e_entry`：程序入口点的地址。
   - `e_phoff`：程序头部的偏移量，指向包含程序段信息的位置。
   - `e_shoff`：节头部的偏移量，指向包含节信息的位置。
   - `e_flags`：处理器特定的标志。
   - `e_ehsize`：ELF头部的大小。
   - `e_phentsize`：程序头项的大小。
   - `e_phnum`：程序头的数量。
   - `e_shentsize`：节头项的大小。
   - `e_shnum`：节头的数量。
   - `e_shstrndx`：节头字符串表的索引。
2. **Elf32_Phdr**: 该结构体表示ELF文件中的程序头（segment descriptor），用于描述文件中的每个段。字段的含义如下：
   - `p_type`：段的类型，如可加载段、动态段等。
   - `p_offset`：段在文件中的偏移。
   - `p_vaddr`：段在内存中的虚拟地址。
   - `p_paddr`：段在物理内存中的地址（通常不使用）。
   - `p_filesz`：段在文件中的大小。
   - `p_memsz`：段在内存中的大小。
   - `p_flags`：段的标志，如可读、可写、可执行等。
   - `p_align`：段的对齐方式。
3. **segment_type**：该枚举定义了常见的段类型，如：
   - `PT_NULL`：表示忽略该段。
   - `PT_LOAD`：表示可加载的段（常见的代码和数据段）。
   - `PT_DYNAMIC`：动态加载信息。
   - `PT_INTERP`：动态加载器的名称。
   - `PT_NOTE`：辅助信息。
   - `PT_SHLIB`：保留段。
   - `PT_PHDR`：程序头。

## 实现加载

```
/* Load a segment from a file into virtual memory at the specified address */
static bool segment_load(int32_t fd, uint32_t offset, uint32_t filesz,
                         uint32_t vaddr) {
    uint32_t vaddr_first_page =
        vaddr & 0xfffff000; // First page of the virtual address
    uint32_t size_in_first_page =
        PG_SIZE - (vaddr & 0x00000fff); // Size of the segment in the first page
    uint32_t occupy_pages = 0;

    // If the segment doesn't fit in a single page
    if (filesz > size_in_first_page) {
        uint32_t left_size = filesz - size_in_first_page;
        occupy_pages = ROUNDUP(left_size, PG_SIZE) + 1; // +1 for the first page
    } else {
        occupy_pages = 1;
    }

    // Allocate memory for the segment in the process's address space
    uint32_t page_idx = 0;
    uint32_t vaddr_page = vaddr_first_page;
    while (page_idx < occupy_pages) {
        uint32_t *pde = pde_ptr(vaddr_page); // Page directory entry
        uint32_t *pte = pte_ptr(vaddr_page); // Page table entry

        // Allocate memory if PDE or PTE doesn't exist
        if (!(*pde & PG_P_1) || !(*pte & PG_P_1)) {
            if (!get_a_page(PF_USER, vaddr_page)) {
                return false;
            }
        }
        vaddr_page += PG_SIZE;
        page_idx++;
    }

    // Read the segment data from the file and load it into memory
    sys_lseek(fd, offset, SEEK_SET);
    sys_read(fd, (void *)vaddr, filesz);
    return true;
}

```

这段代码的功能是将文件中的某个段加载到虚拟内存中的指定地址。首先，代码根据虚拟地址 `vaddr` 和段的文件大小 `filesz` 计算需要多少页内存来容纳这个段。如果段的大小超过了一个页面的剩余空间，就需要分配多页内存。计算方法是：先计算出段的第一个页面的大小，然后如果段的大小超出这个页面，则计算剩余的空间并通过 `ROUNDUP` 函数来确保按页对齐。然后，代码通过遍历虚拟地址空间，检查每一页的页目录项（PDE）和页表项（PTE）是否存在。如果某个页目录项或页表项不存在，说明该页没有分配内存，代码会调用 `get_a_page` 函数为其分配内存页。如果所有页都分配成功，就继续执行后续步骤。一旦内存分配完成，代码使用系统调用 `sys_lseek` 定位到文件的正确位置，然后使用 `sys_read` 读取文件内容并将其加载到虚拟内存中的目标地址 `vaddr`。如果内存分配和文件读取都成功，函数返回 `true`，表示加载成功。如果过程中出现任何问题（如内存分配失败），则返回 `false`。这段代码涉及到虚拟内存和页表的管理，适用于需要处理内存映射和文件加载的操作系统环境，通常用于操作系统的进程管理和程序加载模块。

```
/* Load a user program from the filesystem by pathname, return entry point
 * address or -1 on failure */
static int32_t load(const char *pathname) {
    int32_t ret = -1;
    struct Elf32_Ehdr elf_header;
    struct Elf32_Phdr prog_header;
    k_memset(&elf_header, 0, sizeof(struct Elf32_Ehdr));

    int32_t fd = sys_open(pathname, O_RDONLY); // Open the program file
    if (fd == -1) {
        return -1;
    }

    // Read the ELF header from the file
    if (sys_read(fd, &elf_header, sizeof(struct Elf32_Ehdr)) !=
        sizeof(struct Elf32_Ehdr)) {
        ret = -1;
        goto done;
    }

    // Verify the ELF header
    if (k_memcmp(elf_header.e_ident, "\177ELF\1\1\1", 7) ||
        elf_header.e_type != 2 || elf_header.e_machine != 3 ||
        elf_header.e_version != 1 || elf_header.e_phnum > 1024 ||
        elf_header.e_phentsize != sizeof(struct Elf32_Phdr)) {
        ret = -1;
        goto done;
    }

    Elf32_Off prog_header_offset = elf_header.e_phoff;
    Elf32_Half prog_header_size = elf_header.e_phentsize;

    // Iterate over all program headers
    uint32_t prog_idx = 0;
    while (prog_idx < elf_header.e_phnum) {
        k_memset(&prog_header, 0, prog_header_size);

        // Seek to the program header location in the file
        sys_lseek(fd, prog_header_offset, SEEK_SET);

        // Read the program header from the file
        if (sys_read(fd, &prog_header, prog_header_size) != prog_header_size) {
            ret = -1;
            goto done;
        }

        // If the segment is loadable, load it into memory
        if (PT_LOAD == prog_header.p_type) {
            if (!segment_load(fd, prog_header.p_offset, prog_header.p_filesz,
                              prog_header.p_vaddr)) {
                ret = -1;
                goto done;
            }
        }

        // Move to the next program header
        prog_header_offset += elf_header.e_phentsize;
        prog_idx++;
    }

    ret = elf_header.e_entry; // Return the entry point of the program
done:
    sys_close(fd); // Close the file
    return ret;
}

```

`load` 函数的目的是将一个 ELF 格式的可执行文件加载到内存，并返回程序的入口地址。首先，函数会定义 ELF 头和程序头变量，并读取指定路径的 ELF 文件的头信息。接下来，函数校验文件的格式是否为 ELF，通过检查 ELF 头中的 `e_ident` 字段来确认文件是否合法。ELF 头的前四个字节包含固定的魔数值，其中前三个字节表示 "ELF" 字符串，接下来的一些字节表示文件的位数、字节序等信息。如果这些校验不通过，函数会返回 -1 并关闭文件。如果校验通过，接着会获取程序头的偏移量和大小，程序头描述了文件中的各个段的信息。接下来，函数遍历所有程序头，找到可加载的段（`PT_LOAD` 类型），并为每个段分配内存，将其内容从文件加载到内存中。加载完所有段后，程序的入口地址（`e_entry`）会被赋值给返回值，函数随后关闭文件并返回程序的入口地址。

## 实现sys_execv

```c
/* Replace the current process with the program at the specified path */
int32_t sys_execv(const char *path, const char *argv[]) {
    uint32_t argc = 0;
    while (argv[argc]) {
        argc++; // Count the number of arguments
    }

    // Load the program and get its entry point
    int32_t entry_point = load(path);
    if (entry_point == -1) { // If loading failed, return -1
        return -1;
    }

    TaskStruct *cur = current_thread(); // Get the current running thread (process)
    k_memcpy(cur->name, path, TASK_NAME_ARRAY_SZ); // Update the process name

    // Update the stack with the arguments
    Interrupt_Stack *intr_0_stack =
        (Interrupt_Stack *)((uint32_t)cur + PG_SIZE - sizeof(Interrupt_Stack));
    intr_0_stack->ebx = (int32_t)argv;
    intr_0_stack->ecx = argc;
    intr_0_stack->eip = (void *)entry_point;
    intr_0_stack->esp = (void *)KERNEL_V_START; // Set stack pointer to the highest
                                            // user space address

    // Jump to the entry point of the new process
    asm volatile("movl %0, %%esp; jmp intr_exit"
                 :
                 : "g"(intr_0_stack)
                 : "memory");
    return 0;
}
```

这段代码实现了 `sys_execv` 函数，功能是替换当前进程为指定路径的程序，并传递参数。首先，代码计算传入的参数 `argv` 的个数，然后调用 `load` 函数加载程序。如果加载失败（即 `entry_point` 为 `-1`），则函数返回 `-1`。接下来，函数获取当前正在运行的线程（即当前进程），并将程序的路径更新到线程的名称中。

然后，函数准备中断堆栈（`Interrupt_Stack`），并将程序的参数 `argv`、参数个数 `argc`、入口地址 `entry_point` 和新的栈指针（`esp`）设置到堆栈中。栈指针被设置为内核空间的最高地址 `KERNEL_V_START`。

最后，使用汇编代码将栈指针设置为新的堆栈地址，并跳转到 `intr_exit` 函数，开始执行新的进程。此时，当前进程被完全替换，控制权转交给新的程序。
