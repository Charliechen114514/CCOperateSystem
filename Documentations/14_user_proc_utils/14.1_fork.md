# 实现fork

在Linux中，fork函数的原型是pid_t fork(void)，返回值是数字，该数字有可能是子进程的pid，也有可能是0，也有可能是-1。这是因为Linux中没有直接获取子进程pid的方法，因此为了让父进程知道它的子进程是谁，fork函数会返回子进程的pid给父进程。子进程则通过系统调用getppid获取父进程的pid，而且没有pid为0的进程，因此fork会给子进程返回0，区分父子进程。如果fork调用失败，则返回-1，意味着没有创建子进程。

fork之后，一个进程变成了两个进程，这也说明了fork的作用是克隆进程。fork使得程序从一个进程变成了两个进程，内存中因此多出了一个进程，且每个进程都有独立的地址空间，执行的是相同的代码，但它们各自从fork调用后的代码开始执行。父进程继续执行fork后的代码，而子进程则从fork返回后开始执行。虽然父子进程执行相同的代码，但它们的执行流是独立的，这意味着父子进程在fork后开始有不同的执行路径。

程序在磁盘上是静态的文件，而进程则是程序被加载到内存中后，作为运行中的程序映像。父子进程的内存体积（代码段、数据段等）完全相同，实际上它们就是同一个程序的两个独立实例。在执行时，虽然两者执行的代码是相同的，但由于它们的执行路径不同，具体的执行分支也不同。

通过fork函数，我们创建了一个与父进程一模一样的子进程。父子进程各自独立，拥有独立的地址空间，它们执行的是完全一样的代码。只有在逻辑上，基于pid的判断来区分父子进程的不同执行路径，但这只是程序的设计需要，实际上fork的作用就是克隆一个独立的进程。

fork 的实现本质上是利用现有进程的资源克隆出一个新的进程，并使新进程开始执行。为了实现这一目标，需要完成两个关键步骤：首先是复制进程的资源，其次是将新进程的执行跳转到其代码区域。为了更好地理解fork的实现，我们需要首先明确一个进程的资源有哪些，然后才能知道fork需要复制哪些内容。

进程的资源可以概括为以下几类：

1. 进程控制块（PCB），即 `task_struct`，它相当于进程的“身份证”，包含了进程的基本信息和状态。
2. 程序体，包括代码段和数据段等，它构成了进程的实际内容，是进程的“身体”。
3. 用户栈，进程的局部变量和函数调用栈都存在其中。
4. 内核栈，进程进入内核态时，用来保存上下文环境，同时也用于执行内核代码时的栈空间。
5. 虚拟地址池，每个进程拥有独立的虚拟地址空间，这些地址空间通过虚拟地址池来管理。
6. 页表，帮助进程管理其虚拟地址空间并实现虚拟地址到物理地址的映射。

在 fork 操作中，操作系统会复制上述资源，生成一个与父进程相似的子进程。要使新进程能够执行，只需要将它加入到就绪队列中，并准备好相应的栈，以便它能够正确执行。

在代码实现过程中，需要先做一些基础设施的准备。首先，在 `task_struct` 结构体中增加一个成员变量 `parent_pid`，表示该进程的父进程 PID。默认情况下，父进程的 PID 设置为 `-1`，表示没有父进程。接着，在 `thread.c` 中，定义一个简单的 `fork_pid` 函数来分配 PID。这个函数内部调用了 `allocate_pid`，因为 `allocate_pid` 是一个静态函数，外部无法直接调用，所以我们通过 `fork_pid` 进行封装。这些改动和准备工作为后续 fork 的实现奠定了基础。

通过这种方式，fork 就能在父进程的基础上创建出一个新的子进程，并让子进程从合适的位置开始执行。

## 实现fork

### 安装一个针对fork的虚拟地址位图无需操作的mappings

```
/* Install a single page of vaddr, specifically for cases where the virtual
 * address bitmap does not need to be modified during a fork */
void *get_a_page_without_opvaddrbitmap(PoolFlag pf, uint32_t vaddr) {
    MemoryPool *mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
    lock_acquire(&mem_pool->lock);
    void *page_phyaddr = palloc(mem_pool);
    if (!page_phyaddr) {
        lock_release(&mem_pool->lock);
        return NULL;
    }
    page_table_add((void *)vaddr, page_phyaddr);
    lock_release(&mem_pool->lock);
    return (void *)vaddr;
}

```

 `get_a_page_without_opvaddrbitmap`函数用于为指定的虚拟地址 `vaddr` 分配一页物理内存页，且在分配过程中不修改虚拟地址位图，主要用于 `fork` 操作中的特定情况。

首先，根据 `pf` 标志来判断使用的内存池。如果 `pf` 为 `PF_KERNEL`，则使用内核内存池 `kernel_pool`，否则使用用户内存池 `user_pool`。接着，函数通过 `lock_acquire` 获取相应内存池的锁，确保在分配内存页时不会出现竞态条件。

然后，调用 `palloc` 函数从内存池中分配一页物理内存，如果分配失败，释放锁并返回 `NULL`。如果分配成功，使用 `page_table_add` 将分配到的物理内存页映射到指定的虚拟地址 `vaddr` 上。最后，释放内存池的锁，并返回映射后的虚拟地址 `vaddr`。

## 实现fork的核心

```c
extern void intr_exit(void);

/* Copy parent process's PCB, virtual address bitmap, and stack to child process
 */
static int32_t copy_pcb_vaddrbitmap_stack0(TaskStruct *child_thread,
                                           TaskStruct *parent_thread) {
    /* Copy the entire page containing PCB information and level 0 stack, then
     * modify individual parts */
    k_memcpy(child_thread, parent_thread,
           PG_SIZE);                 // Copy parent process's PCB information
    child_thread->pid = fork_pid(); // Assign a PID to the child process
    child_thread->elapsed_ticks =
        0; // Initialize the child process's elapsed ticks
    child_thread->status = TASK_READY; // Set the child process status to ready
    child_thread->ticks =
        child_thread->priority; // Allocate the time slice to the child process
    child_thread->parent_pid =
        parent_thread->pid; // Set the parent PID for the child process
    child_thread->general_tag.prev = child_thread->general_tag.next =
        NULL; // Initialize task list links
    child_thread->all_list_tag.prev = child_thread->all_list_tag.next = NULL;
    block_desc_init(
        child_thread->u_block_desc); // Initialize memory block descriptors for
                                     // the child process

    /* Copy the virtual address bitmap of the parent process */
    uint32_t bitmap_pg_cnt =
        ROUNDUP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8, PG_SIZE);
    void *vaddr_btmp =
        get_kernel_pages(bitmap_pg_cnt); // Allocate kernel pages for the bitmap
    if (!vaddr_btmp)
        return -1; // Return error if memory allocation fails

    /* Copy the virtual address bitmap to the child process's allocated memory
     */
    k_memcpy(vaddr_btmp, child_thread->userprog_vaddr.vaddr_bitmap.bits,
           bitmap_pg_cnt * PG_SIZE);
    child_thread->userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;

    return 0;
}

```

copy_pcb_vaddrbitmap_stack0将父进程的 PCB、虚拟地址位图和栈复制到子进程中。首先，使用 `k_memcpy` 函数将父进程的 PCB 信息和栈（包括优先级、时间片、父进程 PID 等）复制到子进程的相应位置。接着，为子进程分配一个新的 PID，并初始化其状态、时间片等信息。然后，初始化子进程的内存块描述符。

接下来，代码分配内存用于存储虚拟地址位图，并将父进程的虚拟地址位图复制到子进程中。这保证了子进程和父进程拥有相同的虚拟内存布局。最后，如果内存分配成功，返回 0 表示成功；如果在任何步骤中出现内存分配失败，返回 -1。

```c
/* Copy the child process's code, data, and user stack from the parent process
 */
static void copy_body_stack3(TaskStruct *child_thread,
                             TaskStruct *parent_thread, void *buf_page) {
    uint8_t *vaddr_btmp = parent_thread->userprog_vaddr.vaddr_bitmap.bits;
    uint32_t btmp_bytes_len =
        parent_thread->userprog_vaddr.vaddr_bitmap.btmp_bytes_len;
    uint32_t vaddr_start = parent_thread->userprog_vaddr.vaddr_start;
    uint32_t idx_byte = 0;
    uint32_t idx_bit = 0;
    uint32_t prog_vaddr = 0;

    /* Scan the parent process's user space for allocated pages */
    while (idx_byte < btmp_bytes_len) {
        if (vaddr_btmp[idx_byte]) { // If the page is allocated in the bitmap
            idx_bit = 0;
            while (idx_bit < 8) {
                if ((BITMAP_MASK << idx_bit) & vaddr_btmp[idx_byte]) {
                    prog_vaddr =
                        (idx_byte * 8 + idx_bit) * PG_SIZE + vaddr_start;

                    /* Copy data from the parent process's user space to the
                    kernel buffer buf_page so that it can be copied to the child
                    process's space after page table switch */
                    k_memcpy(buf_page, (void *)prog_vaddr, PG_SIZE);

                    /* Switch to the child process's page table to prevent
                     * modifying the parent process's page table */
                    page_dir_activate(child_thread);

                    /* Allocate virtual address prog_vaddr for the child process
                     */
                    get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);

                    /* Copy data from the kernel buffer to the child process's
                     * user space */
                    k_memcpy((void *)prog_vaddr, buf_page, PG_SIZE);

                    /* Switch back to the parent process's page table */
                    page_dir_activate(parent_thread);
                }
                idx_bit++;
            }
        }
        idx_byte++;
    }
}

```

这段代码的目的是将父进程的代码、数据和用户栈复制到子进程中。首先，代码通过遍历父进程的虚拟地址位图来识别父进程用户空间中已分配的页面。如果某一页面在位图中标记为已分配，则代码会查找该页面的具体虚拟地址（`prog_vaddr`）。

接下来，代码将父进程该页面的数据从用户空间复制到内核缓冲区 `buf_page`，这样做的目的是在切换到子进程的页表后，将数据复制到子进程的对应页面。切换页表时，子进程的页表被激活，防止修改父进程的页表。

然后，代码为子进程的虚拟地址 `prog_vaddr` 分配一个新的页面，并将数据从内核缓冲区复制到子进程的用户空间。复制完数据后，切换回父进程的页表。

通过这种方式，子进程继承了父进程的代码、数据和用户栈。

```c
/* Build the child process's thread stack and set return value */
static int32_t build_child_stack(TaskStruct *child_thread) {
    /* a Set the child process's PID return value to 0 */
    Interrupt_Stack *intr_0_stack =
        (Interrupt_Stack *)((uint32_t)child_thread + PG_SIZE -
                            sizeof(Interrupt_Stack));
    intr_0_stack->eax = 0; // Set the return value of the child process to 0

    /* b Build the ThreadStack for switch_to, placed below the interrupt stack
     */
    uint32_t *ret_addr_in_thread_stack = (uint32_t *)intr_0_stack - 1;

    /***   These lines are not necessary but help to clarify the thread_stack
     * structure ***/
    uint32_t *esi_ptr_in_thread_stack = (uint32_t *)intr_0_stack - 2;
    uint32_t *edi_ptr_in_thread_stack = (uint32_t *)intr_0_stack - 3;
    uint32_t *ebx_ptr_in_thread_stack = (uint32_t *)intr_0_stack - 4;
    /**********************************************************/

    /* Set the stack pointer (ebp) in the thread stack as the top of the stack
     * for switch_to */
    uint32_t *ebp_ptr_in_thread_stack = (uint32_t *)intr_0_stack - 5;

    /* Update the return address for switch_to to intr_exit, so the program
     * returns from interrupt */
    *ret_addr_in_thread_stack = (uint32_t)intr_exit;

    /* These assignments are just to make the thread_stack clearer; they are not
    strictly needed, as they will be overwritten by subsequent pops during
    interrupt return */
    *ebp_ptr_in_thread_stack = *ebx_ptr_in_thread_stack =
        *edi_ptr_in_thread_stack = *esi_ptr_in_thread_stack = 0;
    /*********************************************************/

    /* Set the top of the thread_stack as the stack pointer to be restored
     * during switch_to */
    child_thread->self_kstack = ebp_ptr_in_thread_stack;
    return 0;
}
```

`build_child_stack` 函数的目的是为子进程构建线程栈，并设置返回值。首先，它为子进程的中断栈（`Interrupt_Stack`）设置一个返回值 `eax = 0`，表示子进程的返回值为 0。接下来，函数构建了 `ThreadStack`，这个栈将用于进程切换。`ret_addr_in_thread_stack` 是返回地址，指向 `intr_exit`，使得程序从中断返回时能正确退出。然后，它设置了 `ebp` 和其他寄存器（`ebx`, `edi`, `esi`）为零。这些寄存器会在返回时被恢复。最后，`child_thread->self_kstack` 被设置为新的栈顶位置，供进程切换时使用.

```c
/* Update inode open count */
static void update_inode_open_cnts(TaskStruct *thread) {
    int32_t local_fd = 3, global_fd = 0;
    while (local_fd < MAX_FILES_OPEN_PER_PROC) {
        global_fd = thread->fd_table[local_fd];
        KERNEL_ASSERT(global_fd < MAX_FILE_OPEN);
        if (global_fd != -1) {
            file_table[global_fd].fd_inode->i_open_cnts++; // Increment inode open count for
                                      // regular files
        }
        local_fd++;
    }
}

```

`update_inode_open_cnts` 函数的目的是更新子进程打开的文件的 inode 引用计数。该函数遍历子进程的文件描述符表，检查每个打开的文件，并增加相应文件的 inode 的打开计数（`i_open_cnts`）。这样做是为了确保每个文件的 inode 引用计数准确，防止在父子进程间共享文件时发生错误。

```c
/* Copy the resources occupied by the parent process to the child process */
static int32_t copy_process(TaskStruct *child_thread,
                            TaskStruct *parent_thread) {
    /* Kernel buffer to temporarily hold data from parent process's user space
     * to be copied to the child process */
    void *buf_page = get_kernel_pages(1);
    if (!buf_page) {
        return -1;
    }

    /* a Copy the parent's PCB, virtual address bitmap, and kernel stack to the
     * child process */
    if (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == -1) {
        return -1;
    }

    /* b Create a page table for the child process, which only includes kernel
     * space */
    child_thread->pg_dir = create_page_dir();
    if (!(child_thread->pg_dir)) {
        return -1;
    }

    /* c Copy the parent process's code and user stack to the child process */
    copy_body_stack3(child_thread, parent_thread, buf_page);

    /* Continue with other operations such as setting up the child thread's
     * stack and updating inode counts */
    build_child_stack(child_thread);
    update_inode_open_cnts(child_thread);

    mfree_page(PF_KERNEL, buf_page, 1);
    return 0;
}
```

​	`copy_process` 通过几个步骤来完成父进程资源的复制，包括创建一个内核缓冲区来暂存父进程的用户空间数据、复制父进程的 PCB、虚拟地址位图和内核栈，接着为子进程创建一个新的页表并复制父进程的代码和用户栈，最后设置子进程的线程栈和更新文件的 inode 计数，并释放内存。

## 最后一击

```c
/* Fork the child process. Kernel threads cannot directly call this function */
pid_t sys_fork(void) {
    TaskStruct *parent_thread = current_thread();
    TaskStruct *child_thread =
        get_kernel_pages(1); // Create PCB for the child process
    if (!child_thread) {
        return -1; // Return error if memory allocation fails
    }
    KERNEL_ASSERT(INTR_OFF == get_intr_status() && parent_thread->pg_dir);

    /* Copy resources from the parent process to the child process */
    if (copy_process(child_thread, parent_thread) == -1) {
        return -1;
    }

    /* Add the child process to the ready thread list and all thread list,
     * allowing the scheduler to manage it */
    KERNEL_ASSERT(!elem_find(&thread_ready_list, &child_thread->general_tag));
    list_append(&thread_ready_list, &child_thread->general_tag);
    KERNEL_ASSERT(!elem_find(&thread_all_list, &child_thread->all_list_tag));
    list_append(&thread_all_list, &child_thread->all_list_tag);

    return child_thread
        ->pid; // Return the PID of the child process to the parent
}
```

`sys_fork` 函数实现了创建子进程的功能，首先获取当前进程的 PCB（即 `parent_thread`）。然后为子进程分配内存，并创建一个新的 PCB。如果内存分配失败，函数会返回 `-1`。接下来，使用 `copy_process` 函数将父进程的资源（如 PCB、虚拟地址、内核栈等）复制到子进程中。如果复制过程中出错，同样会返回 `-1`。函数随后将子进程添加到就绪队列和所有进程队列中，确保调度器能够管理它。最后，返回子进程的 PID。需要注意的是，内核线程不能直接调用这个函数，且该函数的执行要求中断处于关闭状态，并且父进程已经拥有页表。

​	我们马上就要有init进程了：修改我们的进程子系统创建函数：

```
    verbose_ccputs("thread_init start\n");

    list_init(&thread_ready_list); // Initialize the ready list
    list_init(&thread_all_list);   // Initialize the all threads list
    lock_init(&pid_lock);

    create_process(init, "init"); 
    /* Create the main thread */
    make_main_thread();

    /* Create the idle thread */
    idle_thread = thread_start("idle", 10, idle, NULL);

    verbose_ccputs("thread_init done\n");
```

​	直接添加一个init函数:`create_process(init, "init"); `就完事了

## 测试

```
#include "include/device/console_tty.h"
#include "include/kernel/init.h"
#include "include/library/kernel_assert.h"
#include "include/thread/thread.h"
#include "include/user/stdio/stdio.h"
#include "include/memory/memory.h"
#include "include/library/ccos_print.h"
#include "include/filesystem/filesystem.h"
#include "include/library/string.h"
#include "include/filesystem/dir.h"
#include "include/syscall/syscall.h"
// void thread_a(void *args);
// void thread_b(void *args);
// void u_prog_a(void);
// void u_prog_b(void);
// int prog_a_pid = 0, prog_b_pid = 0;
// init process here
void init(void);

int main(void)
{
    init_all();
    while(1);
}

// init process here
void init(void)
{
    uint32_t ret_pid = fork();
    if (ret_pid)
    {
        printf("i am father, my pid is %d, child pid is %d\n", getpid(), ret_pid);
    }
    else
    {
        printf("i am child, my pid is %d, ret pid is %d\n", getpid(), ret_pid);
    }
    while (1)
        ;
}

```

![image-20250309235538017](./14.1_fork/image-20250309235538017.png)
