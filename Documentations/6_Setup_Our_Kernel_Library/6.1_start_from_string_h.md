# 构建属于我们自己的内核库1——实现kernel的string.h

​	很快，我们就要一步一步完成其他的内核子系统了。本来，笔者计划是直接进入我们的内存子系统，但是笔者回忆自己的手搓教程，非常悲伤的发现，我们实现其他子系统之前，必须提供一个kernel level的通用库（你可能很快就会着急的反驳我：为什么？不能使用我们的GLibc内建的库函数嘛？哈哈，不着急我会回答的）。本章，我们会着手构建四个重要的库。

1. 实现自己的ASSERT，从而给内核实现我们自己的提前检查。
2. string.h作为内存和字符串中重要的操作库。
3. bitmap.h来实现一个内核层次的位图。
4. list.h来实现一个跟Linux内核同款的非嵌入式的通用链表。

​	之后，笔者还会介绍测试的概念，保证我们的库的质量是可以保证的。

​	前两个，我们在构建内存池子系统的时候会用到。链表是我们构建进程子系统的时候会用到。所以笔者建议的是——即使本章节跟我们的操作系统可以说并没有太多紧密的关系，但是笔者仍然认为，懂得如何实现一个数据结构来服务我们的内核，是非常重要的！

## 回答开头的问题：为什么要自己手搓库

​	很好！那我问你，我们的glibc是“干净的”嘛？我们知道，我们使用的编译器，一般使用的是默认内建的，运行在用户态上的程序而不是内核态上的程序。所以，你会发现很多我们熟悉的memcpy，strcpy等函数，是依赖于用户层的接口的，底层的ABI是我们的操作系统提供的。比如说分配内存策略是采用的人家OS的调用，而不是我们自己的。所以你一旦试图使用用户态的glibc提供的编译器内建函数，他们就会去找更底层的操作系统调用，我们甚至还没实现呢！依赖的malloc，printf需要内核提供的功能甚至还是空白，完全没办法使用于我们的内核。Linux自身就在lib文件夹下实现了自己的一个内核子库。调用时候完全不使用也不能使用GCC的自建库。

## 所以，让我们从一切的根本：ASSERT开始吧

​	我们在这场旅途的终点，实现两种assert，内核态的ASSERT和用户态的assert。不着急，用户态的程序对于现在的我们而言遥远到发指。所以，让我们专心的处理我们内核的ASSERT。

​	assert是断言的意思，主要用于在程序运行时检查某个条件是否成立。如果条件不满足，程序会终止并打印错误信息。我们的gcc就提供了用户态的assert。















