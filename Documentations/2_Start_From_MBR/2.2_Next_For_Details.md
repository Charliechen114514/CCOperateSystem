# 继续我们的MBR事业

​	笔者这里将会进一步详细的讨论一些概念，当然，如果你之前已经编写过操作系统的引导文件过，自然可以跳过这个章节。笔者默认您会NASM和基本的Intel汇编，当然，如果你不是的话，还请看看笔者的唠叨。

​	笔者这一章节，将会复习有关我们MBR编写相关的汇编语言部分，以及关于NASM的简单介绍，到最后，我们会将我们学习到的知识以更好的完善我们的MBR。这样，我们才算是真正的吃透了MBR的编写，才好扎实我们的Loader编写的任务。

## 首先说说NASM

​	上一个章节中，我们看到了NASM一闪而过的身影，NASM是一款汇编器，负责我们汇编代码的编译。他跟我们使用GCC的格式大致相同，这里，我们来看看他能支持的常见的二进制格式文件的生成格式：

| 格式    | 描述                                                        |
| ------- | ----------------------------------------------------------- |
| bin     | 平面二进制文件（例如 DOS_COM, .SYS），此项为默认            |
| ith     | Intel hex 格式                                              |
| srec    | Motorola S-records 格式                                     |
| aout    | Linux a.out 目标文件                                        |
| aoutb   | NetBSD/FreeBSD a.out 目标文件                               |
| coff    | COFF (i386) 目标文件（例如 DJGPP for DOS）                  |
| elf32   | ELF32 (i386) 目标文件（例如 Linux）                         |
| elf64   | ELF64 (x86_64) 目标文件（例如 Linux）                       |
| elfx32  | ELFX32 (x86_64) 目标文件（例如 Linux）                      |
| as86    | Linux as86 (bin86 版本 0.3) 目标文件                        |
| obj     | MS-DOS 16位/32位 OMF 目标文件                               |
| win32   | Microsoft Win32 (i386) 目标文件                             |
| win64   | Microsoft Win64 (x86-64) 目标文件                           |
| rdf     | 可重定位动态目标文件格式 v2.0                               |
| ieee    | IEEE-695 (LADsoft 变体) 目标文件格式                        |
| macho32 | NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (i386) 目标文件   |
| macho64 | NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (x86_64) 目标文件 |
| dbg     | 输出阶段传递的所有信息的跟踪                                |
| elf     | ELF（ELF32 的简称）                                         |
| macho   | MACHO（MACHO32 的简称）                                     |
| win     | WIN（WIN32 的简称）                                         |

​	显然，我们是编译成一个标准的纯粹二进制格式文件，也就是说，我们的代码可以直接到裸的CPU上跑，而不是在可执行文件前添加点东西，这恰好也是我们需要的，我们就是在白手起家。

## 我们说说我们的汇编代码的含义

```
SECTION MBR vstart=MBR_VSTART
```

​	我们首先就是从这个地方上开始。这句话的含义其实也是一句话——

> NASM，请你帮我把这个叫做MBR的代码段的偏移地址设置为MBR_VSTART（在这里，显然是0x7c00）

​	好像还是有点没理解，在这里，我们需要把我们之前写的基于操作系统之上的代码编译中的一些概念再说一说。

### 地址

​	地址就是我们描述我们的符号在内存中的位置，比如说，我们写了一个`int a = 1`的代码，也就是使用了一个int大小的空间来存储了一个1，就是这样的简单。我们会很自然的问：这个1到底在什么地方呢？这就是地址这个概念的派生之处。

​	这里，汇编器的一个工作，就是将我们设计到的内存操作中的符号进行编址。汇编器对我们的代码以及使用到的跟内存相关的数据，根据底层的硬件特性进行排布——也就是正确的将我们写的汇编的助记符转化成我们面向的特定架构的二进制指令。

​	举个例子，我们现在希望在内存中，存储一个这样的一系列数：

```
char 	a;
char 	b;
short 	c;
int 	d;	// 假设我们的long是4个字节大小！
```

​	那么，编译器就会类似的从一个地址的起头，依次排上这样的符号

```
+-----+
|     |
|  d  |	-> int
|     |
|     |
+-----+
|  c  | -=> short
|     |
+-----+
|  b  | -> char
+-----+
|  a  | -> char
+-----+
```

​	我们就是这样将数据编排。当然，这是数据，代码也是类似的。我们当中，会有类似于标签的概念。

​	**静态的说：在汇编中，我们就使用标签来标识我们的模块代码。**

​	**动态的说：我们利用标签的跳转代表我们程序流的跳转。**

​	这样说还是太过于空泛。我们来试试看写代码说话。

### 实验：试试使用NDISASM来进行代码的反汇编

​	你可能对NASM的汇编语法并不算熟悉，这里笔者不打算为难人，我打算给出一段这样的汇编代码

```
section Demo:
    mov ax, $$
    mov ds, ax
    mov ax, [var]
test_label:
    mov ax, $
    jmp test_label

var dw 0x99 
```

​	这个汇编代码没有任何意义，我也打算提示你的是——这个代码你执行也不会有任何肉眼看到的现象，所以笔者建议你省省心将他拷贝到MBR上电执行。

​	我们使用使用包管理软件下载的nasm中附带的ndisasm来进行反汇编。

​	我们知道，汇编作为动词，是将我们的汇编助记符编译成机器看得懂的二进制代码。反汇编那也就很容易猜测了，就是将我们的二进制代码指令还原会可能的汇编代码指令。

​	我们把上面的代码保存成简单的experiment.S文件，然后使用nasm汇编器进行汇编，再使用ndisasm进行反汇编。这样我们就得到了反汇编文件。

```
charliechen@Charliechen:~/$ nasm -o experiment.bin experiment.S 
charliechen@Charliechen:~/$ ndisasm experiment.bin > disexper.asm
```

​	打开ndisasm反汇编得到的disexper.asm文件看看

```
00000000  B80000            mov ax,0x0
00000003  8ED8              mov ds,ax
00000005  A10D00            mov ax,[0xd]
00000008  B80800            mov ax,0x8
0000000B  EBFB              jmp short 0x8
0000000D  99                cwd
0000000E  00                db 0x00
```

​	对比笔者之前写的东西，你会发现看着还是发生了不小的变化。

#### 先说文件格式，我应该怎么读这个反汇编文件

​	注意到的是，这三列的含义分别是——指令所在的内存地址，指令的二进制码和针对这串二进制反汇编得到的代码。

​	举个例子，第一行的含义就是：在地址0000000处的二进制指令是B80000，其含义是`mov ax, 0x0`，也就是将ax寄存器赋值0！

#### 我们的`$$`和`$`去哪里了？

​	你需要注意的是：`$$`和`$`真的不是我们的汇编语法的范畴的内容，它属于特定于编译器的伪指令。

​	我们使用`$`代表当前汇编的地址。

​	`$$`就是代表当前section所属的位置。

​	不太好理解？在上面，我提到了，我们的代码需要做地址的排布，从一个指定的（比如说，我们在编写MBR的时候，就用到了一个我马上会讲到的vstart指令来指定我们的段基址）或者是默认的（这里我们就是用了默认的0）的段基址开始排。所以，$$作为当前段的基址，必然也是0。注意到，汇编是一个标签信息丢失的过程，可以看到，我们反汇编出来的代码只有汇编器翻译的结果，就剩下了一个00.

​	再看我们的jmp short 0x8,我们看到，我们的test_label标签被替换成这个标签所在的地址，一般是我们标签下的第一条指令，应该不难以理解！

​	还有，我们的var也消失了，这也是一个标签，代表这我们存储的一个叫做0x99的数，在这里，我们直接将他所在的地址取出来，使用汇编的解引用操作符`[]`把内容取出来了。就是这样的简单。

#### 反汇编器没有办法完全还原我们的汇编

​	这是应和了我上面说的标签丢失的说法。这就是为什么逆向有时候是困难的，我们就是要尝试将这些莫名其妙的数据人脑还原成他们困难的真实目的。汇编器也不知道我们的9900，到底是`cwd`还是说是单纯的一个0x99的数，我们没法确定。所以，在这里我们完全不知道任何的情况，反汇编器也不知道，索性按照指令去编译了，更改

### 所以，让我们进一步聊一聊section

​	所以，让我们进一步聊一聊section，我们知道，section是一个区域，包含了若干的代码或者是数据（一般会区分，这样的话就不会杂糅在一起），在我们自己书写程序的时候，会使用我们的sections对每一个片区进行分工，比如说。我们可能定义一些功能组和数据组进行数据和代码的分离，使用nasm进行编译后，这些信息（也就是段）实际上就消失了，我们的CPU实在是不关心这个。我的另一个意思是——只使用section不会导致代码编排上的任何变动（除非使用了vstart更新了新的起始地址），这一点在笔者上面对反汇编的介绍中，你可能已经有所察觉。

​	我们阅读的时候，也就可以按照汇编文件里的段理清楚我们的代码到底在作什么，访问那里的数据。这一点非常重要。

#### vstart

​	vstart和org的功能是一致的，都是通知我们的段地址的位置，他只是告知我们的代码需要按照这样提供的基地址来进行。我们知道，8086CPU搞了一个天才办法，使用基地址来定我们的代码和数据在地址上的基调，然后使用偏移地址来决定到底访问这个基地址的哪里。

## 现在我们继续说说下面的代码——引出我们的实模式

```
SECTION MBR vstart=MBR_VSTART
    ; Load Segments
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
```

​	如果你对IA32架构非常的模糊，笔者在自己源码仓库的bonus文件下有对IA架构的实模式的随笔介绍，这里我们就不插入干扰阅读体验了，地址在：

<<<<<<< HEAD
> [Real Mode Introductions](../bonus/Real_Mode.md)
=======
> [[Real Mode Introductions](../bonus/Real Mode.md)](https://github.com/Charliechen114514/CCOperateSystem/blob/main/Documentations/bonus/Real_Mode.md)
>>>>>>> e252c81e4b2429c54c4060913afaa0a81d8d230a

​	显然，我们起手是对我们的寄存器进行一定的复原，当然这个做不做都无所谓的，笔者截取了一个shot：

```
<bochs:7> sreg
es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
cs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1
        Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed
ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1
tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1
gdtr:base=0x000f9e67, limit=0x30
idtr:base=0x00000000, limit=0x3ff
```

​	你可以看到，我们的寄存器实际上已经是0x0000了，但是为了保证我们的MBR的状态是确定的，还是务必正确的初始化我们的寄存器比较好。

```
    mov sp, MBR_VSTART
    mov ax, 0xb800
    mov gs, ax
```

​	接下来，是把我们的sp寄存器，也就是我们的栈指向我们的代码段上，这个没啥特殊的含义目前看起来，笔者这里的习惯是让寄存器经可能表达完全。

​	接下来就是讲究的地方了。笔者这里卖了关子，这个0xb800是啥玩意呢？我们知道。我们实际上就是把这个数值直接给了gs寄存器，也就说，我们现在的基于GS能够访问到的地址是`0xb800:0x0000~0xb800:0xFFFF`。这个有什么讲究嘛？

​	答案揭晓，回到笔者在这里埋下的一张表：

> [上一节](./2.1_Cody_First.md)的1MB地址安排表，现在请我们看到这个地方

| 地址起始 | 地址末端 | 大小 | 作用                     |
| -------- | -------- | ---- | ------------------------ |
| B8000    | BFFFF    | 32KB | 用于文本模式显示适配器。 |

​	现在，我们实际上就是将我们的书写指针指向了这片区域，然后准备往里面写字符。具体上我们的这片区域到底是如何搬运到了显卡上，笔者这里不做介绍（其实是没考证），但是需要注意的是——我们的地址访问其实不等价于内存条大小

> 事实上，我们的地址访问屏蔽了我们如何检索设备并与之交互的。地址之下，除了是内存条，还可以是显卡，网卡等等，最终这个地址可以是多大的大小，取决于我们主板的地址总线长度和CPU芯片支持的地址引脚的个数。

​	我们只需要知道的是，访问这个地址范围就是跟我们的显卡直接交互。所以，从系统编程的角度，我们想要看到点现象，就必须往里面写点东西进去。那问题来了，**写什么？怎么写？**

```
    ; 存储字符到 [gs:di]
    mov [gs:di], al     ; 将字符存储到 gs:di
    inc di              ; 更新 di，指向下一个存储位置

    ; 存储 0xA4 到 [gs:di]
    mov byte [gs:di], 0xA4
    inc di              ; 更新 di，指向下一个存储位置
```

​	跳跃一下，我们来到这个地方。显然，我们是将al寄存器的内容放到了我们的`[gs:di]`，也就是我们的gs（刚刚我们已经设置gs是0xb800）和di组合的有效地址EA。我们实际上就是向地址`GS << 4 + DI`的地址上写东西。写什么呢？

​	我们知道，显卡实际上完全不知道我们的内容信息到底是什么，我们必须约定一个方式，让显卡可以正确的理解我们的意图，或者倒过来说，让我们正确的操作我们的显卡。

​	**办法是简单的，向里面依次写字符和字符显示的控制信息即可！**字符信息自然是从ASCII表而来，想知道ASCII（美国信息交换标准代码）是什么的自行检索，这里就不说了。但问题在于，什么是字符控制信息呢？

​	简单的说，**就是我们如何显示这些字符**。我们知道，对于彩色的文本模式，我们有的是字符本身的颜色和字符所在格子内的背景颜色，**这些信息使用一个字节来表达了**，请看下面的位图。

```
;   ---------------------------------
;   | K | R | G | B | I | R | G | B |
;   ---------------------------------
```

​	先看字符本身的颜色。这个事情，看下面的表格。I实际上说的是颜色的深浅。

| R    | G    | B    | 颜色 I=0 | 颜色I=1 |
| ---- | ---- | ---- | -------- | ------- |
| 0    | 0    | 0    | 黑       | 灰      |
| 0    | 0    | 1    | 蓝       | 浅蓝    |
| 0    | 1    | 0    | 绿       | 浅绿    |
| 0    | 1    | 1    | 青       | 浅青    |
| 1    | 0    | 0    | 红       | 浅红    |
| 1    | 0    | 1    | 品红     | 浅品红  |
| 1    | 1    | 0    | 棕       | 黄      |
| 1    | 1    | 1    | 白       | 亮白    |

​	对于背景色是类似的，其中，K表达了我们字符要不要闪烁。

> 小测试：所以，当我们的字符控制信息是A4的时候，我们表达了什么含义呢？
>
> 答案是：A4写成2进制数是1 010 0 100，也就是字符闪烁，背景色为绿色，字符颜色是红色。结束。

​	你可以试试使用其他的方式来显示字符，很有趣的（笑）

​	所以，**我们的显卡信息分为两部分写入一个显示的字符：每一个部分一个字节，第一个部分是我们的字符信息，我们打算打印什么字符。第二个部分是字符显示控制信息，已经在上面的表格中列写与举例了，这里不再说明**

## 使用BIOS中断来更加快捷的完成我们的任务

​	现在，我知道有想法的朋友已经准备大展身手，准备在这个BIOS的显示中开展蓝图，但是先别着急，很多功能实际上BIOS已经提供了，在这里，请把你的目光移动到这个地方上来：

```
; clear the screen by using 0x06

    mov ax, 0x0600
    mov bx, 0x0700
    xor cx, cx
    mov dx, 0x18f4
    int 0x10

; 设置光标到第一行、第一列 (DH = 0, DL = 0)
    mov ah, 0x02     ; BIOS中断0x10的设置光标位置功能
    mov bh, 0        ; 页码0
    mov dh, 0        ; 行号0 (第一行)
    mov dl, 0        ; 列号0 (第一列)
    int 0x10         ; 调用中断

; get the cursor
    mov ah, 0x02
    mov bh, 0
    int 0x10
```

​	这是啥？我们终于留意到了一个新的身影。int是什么？当然不是C语言的整数声明（笑）他表达的是——向一个目标发起0x10号（16号中断），对谁呢？上一节我们说到，BIOS初始化了一部分中断向量表，在那里BIOS已经为我们提供了一部分的基础输入输出功能了，程序员的一个素质就是学会复用。现在，让我们看看，BIOS的中断向量里提供了什么宝贝：

| 中断号 | AH功能号 | 快速功能说明                               | 参数含义                                                     |
| ------ | -------- | ------------------------------------------ | ------------------------------------------------------------ |
| 10     | 6        | 屏幕初始化或上卷                           | AL=上卷行数 AL=0 整个窗口空白 <br>BH=卷入行属性 <br>CH=左上角行号 (CH、CL)＝窗口的左上角位置(Y坐标，X坐标) CL=左上角列号 <br>DH=右下角行号 (DH、DL)＝窗口的右下角位置(Y坐标，X坐标) DL=右下角列号 |
| 10     | 2        | 置光标位置                                 | BH=页号 DH=行(X坐标),DL=列(Y坐标)                            |
| 10     | 3        | 读光标位置(在文本坐标下，读取光标各种信息) | BH=页号                                                      |

​	完整的表在笔者提供的扩展中，感兴趣的朋友可以自己琢磨。这里笔者就只是说明自己写的OS使用到的内容。

​	首先，我们做的是初始化的部分的内容。

```
    mov ax, 0x0600
    mov bx, 0x0700
    xor cx, cx
    mov dx, 0x184f
    int 0x10  
```

​	当然，使用`mov ah, 6`也是可以的。至于DX为什么是0x184f，我们作点计算。首先，计算机的世界中是以0作为起始的，其次，VGA屏幕大小是25x80个字符。结合手册说明，我们的DH是右下角的坐标位置，DH是0x18，也就是第25行，DL是0x4F，也就是80列，恰好是一个屏幕，所以也就是直接将我们的屏幕卷干净。所以实现了清屏。

​	关于其他的分析，笔者建议你如法炮制，自行的依照注释进行理解。

​	对于中断的概念，笔者这里先不谈论，等到我们写好了加载器加载好了我们的操作系统后，我们会在操作系统再次详细的讨论中断这个概念，在这里，只需认为我们是在向我们的BIOS请求一定的服务即可。

```
%define MBR_VSTART          0x7c00
%define STOP                jmp $
%define PLACE_MBR_MAGIC     db 0x55, 0xaa

SECTION MBR vstart=MBR_VSTART
    ; Load Segments
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, MBR_VSTART
    mov ax, 0xb800
    mov gs, ax

; clear the screen by using 0x06

    mov ax, 0x0600
    mov bx, 0x0700
    xor cx, cx
    mov dx, 0x18f4
    int 0x10

; 设置光标到第一行、第一列 (DH = 0, DL = 0)
    mov ah, 0x02     ; BIOS中断0x10的设置光标位置功能
    mov bh, 0        ; 页码0
    mov dh, 0        ; 行号0 (第一行)
    mov dl, 0        ; 列号0 (第一列)
    int 0x10         ; 调用中断

; get the cursor
    mov ah, 0x02
    mov bh, 0
    int 0x10
    ; 设置 di 为目标存储地址，假设存储从 0x00 开始
    mov di, 0x00        ; 设置 gs 段的偏移地址为 0

    ; 字符串数据
    mov si, welcome     ; 将字符串的地址传递给 si
    
store_loop:
    lodsb               ; 加载一个字符到 al，并更新 si
    or al, al           ; 检查字符是否为 0（字符串结束符）
    jz done             ; 如果字符为 0，结束循环

    ; 存储字符到 [gs:di]
    mov [gs:di], al     ; 将字符存储到 gs:di
    inc di              ; 更新 di，指向下一个存储位置

    ; 存储 0xA4 到 [gs:di]
    mov byte [gs:di], 0xA4
    inc di              ; 更新 di，指向下一个存储位置

    jmp store_loop      ; 继续处理下一个字符

done:
    STOP                ; 程序结束

welcome db "Hello, Charlie's OS", 0
welcome_len equ $ - welcome
times 510 - ($ - $$) db 0
PLACE_MBR_MAGIC
```

​	已经没有其他的东西了。我们下一个章节就会来讨论加载器和其他更加高级的NASM的用法。

## 下一篇

[Ready Jump To The Loader](./2.3_Start_Our_Loader_Road.md)

## 扩展：关于BIOS的中断号和提供的功能参考表

> [BIOS中断表(整理更新中2013-10-23)_int13h 256色-CSDN博客](https://blog.csdn.net/xa04xa04/article/details/12871425)

| INT  | AH   | 功能                                       | 调用参数                                                     | 返回参数                                                     |
| ---- | ---- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 10   | 0    | 设置显示方式                               | AL=00 40×25黑白方式 AL=01 40×25彩色方式 AL=02 80×25黑白方式 AL=03 80×25彩色方式 AL=04 320×200彩色图形方式 AL=05 320×200黑白图形方式 AL=06 320×200黑白图形方式 AL=07 80×25单色文本方式 AL=08 160×200 16色图形 (PCjr) AL=09 320×200 16色图形 (PCjr) AL=0A 640×200 16色图形 (PCjr) AL=0B 保留(EGA) AL=0C 保留(EGA) AL=0D 320×200 彩色图形 (EGA) AL=0E 640×200 彩色图形 (EGA) AL=0F 640×350 黑白图形 (EGA) AL=10 640×350 彩色图形 (EGA) AL=11 640×480 单色图形 (EGA) AL=12 640×480 16色图形 (EGA) AL=13 320×200 256色图形 (EGA) AL=40 80×30 彩色文本(CGE400) AL=41 80×50 彩色文本(CGE400) AL=42 640×400 彩色图形(CGE400)对于超级VGA显示卡， 我们可用AX＝4F02H和下列BX的值来设置其显示模式。 BX显示模式属性BX显示模式属性 100H 640×400 256色 101H 640×480 256色 102H 800×600 16色 103H 800×600 256色 104H 1024×768 16色 105H 1024×768 256色 106H 1280×1024 16色 107H 1280×1024 256色 108H 80×60文本模式 109H 132×25文本模式 10AH 132×43文本模式 10BH 132×50文本模式 10CH 132×60文本模式 |                                                              |
| 10   | 1    | 置光标类型                                 | (CH)0-3=光标起始行 {CH低四位＝光标的起始行} (CL)0-3=光标结束行 {CL低四位＝光标的终止行} |                                                              |
| 10   | 2    | 置光标位置                                 | BH=页号 DH=行(X坐标),DL=列(Y坐标)                            |                                                              |
| 10   | 3    | 读光标位置(在文本坐标下，读取光标各种信息) | BH=页号                                                      | CH=光标起始行 DH=行,DL=列                                    |
| 10   | 4    | 读光笔位置(获取当前状态和光笔位置)         |                                                              | AH=0 光笔未触发  =1 光笔触发 CH=象素行 (图形Y坐标，显示模式：04H~06H) BX=象素列 (图形Y坐标，显示模式：0DH~10H) DH=字符行 (文本Y坐标) DL=字符列 (文本X坐标) |
| 10   | 5    | 置显示页(即选择活动的显示页)               | AL=页号AL＝显示页 对于CGA、EGA、MCGA和VGA，其显示页如下表所列： 模式页数显示器类型 00H、01H 0~7CGA、EGA、MCGA、VGA 02H、03H 0~3CGA 02H、03H 0~7EGA、MCGA、VGA 07H 0~7EGA、VGA 0DH 0~7EGA、VGA 0EH 0~3EGA、VGA 0FH 0~1EGA、VGA 10H 0~1EGA、VGA 对于PCjr： AL＝80H——读取CRT/CPU页寄存器 81H——设置CPU页寄存器 82H——设置CRT页寄存器 83H——设置CRT/CPU页寄存器 BH＝CRT页(子功能号82H和83H) BL＝CPU页(子功能号81H和83H) | 对PCjr在子功能80H~83H调用下，有： BH＝CRT页寄存器， BL＝CPU页寄存器 |
| 10   | 6    | 屏幕初始化或上卷                           | AL=上卷行数 AL=0 整个窗口空白 BH=卷入行属性 CH=左上角行号 (CH、CL)＝窗口的左上角位置(Y坐标，X坐标) CL=左上角列号 DH=右下角行号 (DH、DL)＝窗口的右下角位置(Y坐标，X坐标) DL=右下角列号 |                                                              |
| 10   | 7    | 屏幕初始化或下卷                           | AL=下卷行数 AL=0 整个窗口空白 BH=卷入行属性 CH=左上角行号 (CH、CL)＝窗口的左上角位置(Y坐标，X坐标) CL=左上角列号 DH=右下角行号 (CH、CL)＝窗口的左上角位置(Y坐标，X坐标) DL=右下角列号 |                                                              |
| 10   | 8    | 读光标位置的字符和属性                     | BH=显示页                                                    | AH=属性 AL=字符                                              |
| 10   | 9    | 在光标位置显示字符及属性                   | BH=显示页 AL=字符 BL=属性 属性(文本模式)或颜色(图形模式) CX=字符重复次数(重复输出字符的次数) |                                                              |
| 10   | A    | 在光标位置显示字符                         | BH=显示页 BL＝颜色(图形模式，仅适用于PCjr) AL=字符 CX=字符重复次数(重复输出字符的次数) |                                                              |
| 10   | B    | 置彩色调板(320×200图形)                    | BH=彩色调板ID BL=和ID配套使用的颜色设置颜色： BH＝00H，BL＝颜色 选择调色板： BH＝01H，BL＝调色板(320×200、4种颜色的图形模式) |                                                              |
| 10   | C    | 写象素                                     | DX=行(0-199) CX=列(0-639) AL=象素值 BH＝页码                 |                                                              |
| 10   | D    | 读象素                                     | DX=行(0-199) CX=列(0-639) BH＝页码                           | AL=象素值                                                    |
| 10   | E    | 显示字符 (光标前移)                        | AL=字符 BL=前景色(图形模式) BH＝页码                         |                                                              |
| 10   | F    | 取当前显示方式                             |                                                              | AH=字符列数 AL=显示方式(参见功能00H中的说明)                 |
| 10   | 10   | 颜色中断                                   | 00H — 设置调色板寄存器 01H — 设置边框颜色 02H — 设置调色板和边框 03H — 触发闪烁/亮显位 07H — 读取调色板寄存器 08H — 读取边框颜色 09H — 读取调色板和边框 10H — 设置颜色寄存器 12H — 设置颜色寄存器块 13H — 设置颜色页状态 15H — 读取颜色寄存器 17H — 读取颜色寄存器块 1AH — 读取颜色页状态 1BH — 设置灰度值 |                                                              |
| 10   | 11   | 字体中断                                   | 00H 装入用户字体和可编程控制器 10H 装入用户字体和可编程控制器 01H 装入8×14 ROM字体和可编程控制器 11H 装入8×14 ROM字体和可编程控制器 02H 装入8×8 ROM字体和可编程控制器 12H 装入8×8 ROM字体和可编程控制器 03H 设置块指示器 04H 装入8×16 ROM字体和可编程控制器 14H 装入8×16 ROM字体和可编程控制器 20H 设置 INT 1Fh字体指针 21H 为用户字体 设置 INT 43h 22H 为8×14 ROM 字体设置INT 43H 23H 为8×8 ROM 字体设置INT 43H 24H 为8×16 ROM 字体设置INT 43H 30H 读取字体信息 |                                                              |
| 10   | 12   | 显示器的配置中断                           | 10H — 读取配置信息 20H — 选择屏幕打印 30H — 设置扫描行 31H — 允许/禁止装入缺省调色板 32H — 允许/禁止显示 33H — 允许/禁止灰度求和 34H — 允许/禁止光标模拟 35H — 切换活动显示 36H — 允许/禁止屏幕刷新 |                                                              |
| 10   | 13   | 显示字符串(适用AT)                         | ES:BP=串地址 CX=串长度 DH,DL=起始行,列 BH=页号 AL=0,BL=属性(闪烁1位,背景色3位,高亮1位,前景色3位.共8位) 串:char,char,... AL=1,BL=属性(闪烁1位,背景色3位,高亮1位,前景色3位.共8位) 串:char,char,... AL=2 串:char,attr,char,attr,... AL=3 串:char,attr,char,attr,... | 光标返回起始位置  光标跟随移动  光标返回起始位置  光标跟随移动 |
| 10   | 1A   | 读取/设置显示组合编码，仅PS/2有效          | 略                                                           |                                                              |
| 10   | 1B   | 读取功能/状态信息，仅PS/2有效              | 略                                                           |                                                              |
| 10   | 1C   | 保存/恢复显示器状态，仅PS/2有效            | 略                                                           |                                                              |
| 11   |      | 设备检验                                   |                                                              | AX=返回值 bit0=1,配有磁盘 bit1=1,80287协处理器 bit4,5=01,40×25BW(彩色板)    =10,80×25BW(彩色板)    =11,80×25BW(黑白板) bit6,7=罗盘驱动器 bit9,10,11=RS-232板号 bit12=游戏适配器 bit13=串行打印机 bit14,15=打印机号 |
| 12   |      | 测定存储器容量                             |                                                              | AX=字节数(KB)                                                |
| 13   | 0    | 软盘系统复位(磁盘系统复位)                 | DL＝驱动器， 00H~7FH：软盘； 80H~0FFH：硬盘                  | CF＝0——操作成功，AH＝00H， 否则，AH＝状态代码，参见功能号01H中的说明 |
| 13   | 1    | 读软盘状态                                 | DL＝驱动器， 00H~7FH：软盘； 80H~0FFH：硬盘                  | 成功:CF=0 (13中断都可以依靠这个判断) 失败:CF=1 (13中断都可以依靠这个判断)AL=状态字节00H — 无错 01H — 非法命令 02H — 地址目标未发现 03H — 磁盘写保护(软盘) 04H — 扇区未发现 05H — 复位失败(硬盘) 06H — 软盘取出(软盘) 07H — 错误的参数表(硬盘) 08H — DMA越界(软盘) 09H — DMA超过64K界限 0AH — 错误的扇区标志(硬盘) 0BH — 错误的磁道标志(硬盘) 0CH — 介质类型未发现(软盘) 0DH — 格式化时非法扇区号(硬盘) 0EH — 控制数据地址目标被发现(硬盘) 0FH — DMA仲裁越界(硬盘) 10H — 不正确的CRC或ECC编码 11H — ECC校正数据错(硬盘) CRC:Cyclic Redundancy Check code ECC:Error Checking & Correcting code 20H — 控制器失败 40H — 查找失败 80H — 磁盘超时(未响应) AAH — 驱动器未准备好(硬盘) BBH — 未定义的错误(硬盘) CCH — 写错误(硬盘) E0H — 状态寄存器错(硬盘) FFH — 检测操作失败(硬盘) |
| 13   | 2    | 读磁盘                                     | AL=扇区数 CH,CL=磁盘号,扇区号 DH=磁头号 ES:BX=数据缓冲区地址 DL:驱动器号 00H~7FH：软盘； 80H~0FFH：硬盘 | 读成功:CF=0,AH=0     AL=读取的扇区数 读失败:CF=1,AH=出错代码 (参见功能号01H中的说明) |
| 13   | 3    | 写磁盘                                     | 同上                                                         | 写成功:CF=0,AH=0     AL=写入的扇区数 写失败:CF=1,AH=出错代码 |
| 13   | 4    | 检验磁盘扇区                               | 同上(ES:BX不设置)                                            | 成功:CF=0,AH=0    AL=检验的扇区数 失败:CF=1,AH=出错代码      |
| 13   | 5    | 格式化盘磁道                               | ES:BX=磁道地址AL＝交替(Interleave) CH＝柱面 DH＝磁头 DL＝驱动器， 00H~7FH：软盘； 80H~0FFH：硬盘 ES:BX＝地址域列表的地址 | 成功:CF=0,AH=0 失败:CF=1,AH=出错代码                         |
| 13   | 6    | 格式化坏磁道                               | AL＝交替 CH＝柱面 DH＝磁头 DL＝80H~0FFH：硬盘 ES:BX＝地址域列表的地址 | 成功:CF=0,AH=0 失败:CF=1,AH=状态代码，参见功能号01H中的说明  |
| 13   | 7    | 格式化驱动器                               | AL＝交替 CH＝柱面 DL＝80H~0FFH：硬盘                         | 成功:CF=0,AH＝00H， 失败:CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | 8    | 读取驱动器参数                             | DL＝驱动器: 00H~7FH：软盘； 80H~0FFH：硬盘                   | 失败:CF=1,AH＝状态代码，参见功能号01H中的说明 成功:CF=0, BL＝01H — 360K ＝02H — 1.2M ＝03H — 720K ＝04H — 1.44M CH＝柱面数的低8位 CL的位7-6＝柱面数的该2位 CL的位5-0＝扇区数 DH＝磁头数 DL＝驱动器数 ES:DI＝磁盘驱动器参数表地址 |
| 13   | 9    | 初始化硬盘参数                             | DL＝80H~0FFH：硬盘(还有有关参数表问题，在此从略)             | 操作成功，CF=0,AH＝00H， 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | A    | 读长扇区，每个扇区随带四个字节的ECC编码    | AL＝扇区数 CH＝柱面 CL＝扇区 DH＝磁头 DL＝80H~0FFH：硬盘 ES:BX＝缓冲区的地址 | 成功:CF=0,AH＝00H，AL＝传输的扇区数， 否则:CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | B    | 写长扇区，每个扇区随带四个字节的ECC编码    | AL＝扇区数 CH＝柱面 CL＝扇区 DH＝磁头 DL＝80H~0FFH：硬盘 ES:BX＝缓冲区的地址 | 成功，CF=0,AH＝00H，AL＝传输的扇区数， 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | C    | 查寻                                       | CH＝柱面的低8位 CL(7-6位)＝柱面的高2位 DH＝磁头 DL＝80H~0FFH：硬盘 | 成功，CF=0,AH＝00H， 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | D    | 硬盘系统复位                               | DL＝80H~0FFH：硬盘                                           | 成功，CF=0,AH＝00H， 失败，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | E    | 读扇区缓冲区                               | ES:BX＝缓冲区的地址                                          | 操作成功，CF=0, 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | F    | 写扇区缓冲区                               | ES:BX＝缓冲区的地址                                          | 操作成功，CF=0, 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | 10   | 读取驱动器状态                             | DL＝80H~0FFH：硬盘                                           | 操作成功，CF=0,AH＝00H， 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | 11   | 校准驱动器                                 | DL＝80H~0FFH：硬盘                                           | 操作成功，CF=0,AH＝00H， 否则，CF=1,AH＝状态代码，参见功能号01H中的说明 |
| 13   | 12   | 控制器RAM诊断                              |                                                              | 成功:CF=0, 否则，CF=1,AH＝状态代码，参见功能号01H中的说明    |
| 13   | 13   | 控制器驱动诊断                             |                                                              | AH＝状态代码，参见功能号01H中的说明                          |
| 13   | 14   | 控制器内部诊断                             |                                                              | AH＝状态代码，参见功能号01H中的说明                          |
| 13   | 15   | 读取磁盘类型                               | DL＝驱动器， 00H~7FH：软盘； 80H~0FFH：硬盘                  | 失败，CF=1,AH＝状态代码，参见功能号01H中的说明 否则，CF=0,AH＝00H — 未安装驱动器 ＝01H — 无改变线支持的软盘驱动器 ＝02H — 带有改变线支持的软盘驱动器 ＝03H — 硬盘，CX:DX＝512字节的扇区数 |
| 13   | 16   | 读取磁盘变化状态                           | DL＝00H~7FH：软盘                                            | 磁盘未改变，CF=0,AH＝00H， 否则，CF=1,AH＝06H，参见功能号01H中的说明 |
| 13   | 17   | 设置磁盘类型                               | DL＝00H~7FH：软盘 AL＝00H — 未用 ＝01H — 360K在360K驱动器中 ＝02H — 360K在1.2M驱动器中 ＝03H — 1.2M在1.2M驱动器中 ＝04H — 720K在720K驱动器中 | 操作成功，CF=0,AH＝00H， 否则，CF=1,AH＝状态编码，参见功能号01H中的说明 |
| 13   | 18   | 设置格式化媒体类型                         | CH＝柱面数 CL＝每磁道的扇区数 DL＝00H~7FH：软盘              | 操作成功，CF=0,AH＝00H， ES:DI＝介质类型参数表地址， 否则，CF=1,AH＝状态编码，参见功能号01H中的说明 |
| 13   | 19   | 磁头保护(仅在PS/2中有效)                   |                                                              |                                                              |
| 13   | 1A   | 格式化ESDI驱动器(仅在PS/2中有效)           |                                                              |                                                              |
| 13   | 41   | 检验扩展功能是否存在(是否为扩展8.46GB硬盘) | BX = 55AAh DL = 驱动器号                                     | CF=0, AH = 扩展功能的主版本号 AL = 内部使用 BX = AA55h CX = API 子集支持位图 CF=1, AH = 错误码 01h，无效命令 这个调用检验对特定的驱动器是否存在扩展功能。 如果进位标志置 1则此驱动器不支持扩展功能。 如果进位标志为 0，同时 BX = AA55h，则存在扩展功能。 此时 CX 的 0 位表示是否支持第一个子集， 1位表示是否支持第二个子集. 对于 1.x 版的扩展 Int13H 来说，主版本号 AH = 1。 AL 是副版本号，但这仅限于 [BIOS](https://so.csdn.net/so/search?q=BIOS&spm=1001.2101.3001.7020) 内部使用， 任何软件不得检查 AL 的值。 |
| 13   | 42   | 扩展读 (大于8.46GB硬盘专用)                | DL = 驱动器号 DS:DI = 磁盘地址数据包(Disk Address Packet)    | 成功:CF=0，AH = 0 失败:CF=1，AH = 错误码这个调用将磁盘上的数据读入内存。如果出现错误，DAP 的 BlockCount项中则记录了出错前实际读取的数据块个数 |
| 14   | 0    | 初始化串行通讯口                           | AL=初始化参数 DX=通讯口号(COM0,COM1,...) AL＝初始化参数， 参数的说明如下： 波特率奇偶位停止位字的位数 76543210 000 = 110X0 = None0 = 1 bit10 = 7 bits 001 = 15001 = Odd1 = 2 bits11 = 8 bits 010 = 30011 = Even 011 = 600 100 = 1200 101 = 2400 110 = 4800 111 = 9600对于PS/2，可用INT 14H之功能04H和05H来初始化其通信速率大于9600。 | AH=通读口状态 AL=调制解调器状态AH＝通信口状态， 各状态位为1时的含义如下： 位7—超时 位6—传递移位寄存器为空 位5—传递保持寄存器为空 位4—发现终止位3—发现帧错误 位2—发现奇偶错 位1—发现越界错 位0—接受数据准备好 AL＝Modem状态 位7—接受单线信号诊断 位6—环指示器 位5—数据发送准备好 位4—清除数据，再发送位3—改变在接受线上的信号诊断 位2—后边界环指示器 位1—改变“数据准备好”状态 位0—改变“清除—发送”状态 |
| 14   | 1    | 向串行通讯口写字符                         | AL=字符 DX=通讯口号(COM0,COM1...)                            | 写成功:(AH)7=0 写失败:(AH)7=1 (AH)0-6=通讯口状态             |
| 14   | 2    | 从串行通讯口读字符                         | DX=通讯口号(COM0,COM1...)                                    | 读成功:(AH)7=0     (AL)=字符 写失败:(AH)7=1 (AH)0-6=通讯口状态 |
| 14   | 3    | 取通讯口状态                               | DX=通讯口号(COM0,COM1...)                                    | AH=通讯口状态 AL=调制解调器状态(参见功能号00H中的说明)       |
| 14   | 4    | 扩充初始化通信口(仅在PS/2中有效)           |                                                              |                                                              |
| 15   | 0    | 启动盒式磁带马达                           |                                                              | AH＝状态(86H，若未安装盒式磁带机)                            |
| 15   | 1    | 停止盒式磁带马达                           |                                                              | AH＝状态(86H，若未安装盒式磁带机)                            |
| 15   | 2    | 磁带分块读                                 | ES:BX=数据传输区地址 CX=字节数                               | AH=状态字节 AH=00 读成功  =01 冗余检验错  =02 无数据传输  =04 无引导操作成功， DX＝实际读入的字节数， ES:BX指向最后一个字节的后面地址， 否则， AH＝状态码，其值含义如下： 01H —— CRC校验码错 80H —— 非法命令 02H —— 位信号混乱 86H —— 未安装盒式磁带机 04H —— 无发现数据 |
| 15   | 3    | 磁带分块写                                 | DS:BX=数据传输区地址 CX=字节数                               | 同上                                                         |
| 15   | F    | 格式化ESDI驱动器定期中断(仅在PS/2中有效)   |                                                              |                                                              |
| 15   | 21   | 读/写自检(POST)错误记录(仅在PS/2中有效)    |                                                              |                                                              |
| 15   | 4F   | 键盘截听(仅在PS/2中有效)                   |                                                              |                                                              |
| 15   | 80   | 打开设备                                   | BX＝设备号 CX＝进程号                                        | 操作成功，AH＝00H， 否则，AH＝状态码                         |
| 15   | 81   | 关闭设备                                   | BX＝设备号 CX＝进程号                                        | 操作成功，AH＝00H， 否则，AH＝状态码                         |
| 15   | 82   | 进程终止                                   | BX＝进程号                                                   | 操作成功，AH＝00H， 否则，AH＝状态码                         |
| 15   | 83   | 事件等待                                   | 若需要事件等待，则： AL＝00H CX:DX＝千分秒 ES:BX＝信号量字节的地址 否则，调用参数为 AL＝01H | 成功:CF＝0， 否则:CF＝1                                      |
| 15   | 84   | 读游戏杆                                   | DX＝00H——读取开关设置 ＝01H——读取阻力输入                    | CF＝1H——操作失败， 否则， DX＝00H时，AL＝开关设置(位7～4) DX＝01H时， AX:A(x) BX:A(y) CX:B(x) DX:B(y) |
| 15   | 85   | 系统请求(SysReq)键                         | AL ＝00H——键按下 ＝01H——键放开                               | 操作成功，AH＝00H， 否则，AH＝状态码                         |
| 15   | 86   | 延迟                                       | CX:DX＝千分秒                                                | 操作成功，AH＝00H                                            |
| 15   | 87   | 从常规内存和扩展内存之间移动扩展内存块     | 偏移量存储的信息 00h-0Fh 保留，但现全为0 10h-11h 段的长度(2CX-1或更大) 12h-14h 24位源地址 15h 访问权限字节(其值为93h) 16h-17h 保留，但现全为0 18h-19h 段的长度(2CX-1或更大) 1Ah-1Ch 24位目标源地址 1Dh 访问权限字节(其值为93h) 1Eh-2Fh 保留，但现全为0 | 操作成功，AH＝00H， 否则，AH＝状态码，其含义如下： 01H —— RAM奇偶错 02H —— 异常中断错 03H —— 20号线门地址失败 |
| 15   | 88   | 读取扩展内存大小                           |                                                              | AX＝扩展内存字节数(以K为单位)                                |
| 15   | 89   | 进入保护模式，CPU从实模式进入保护模式      | BH＝IRQ0的中断号 BL＝IRQ8的中断号 ES:SI＝GDT的地址(参见功能号87H) | 操作失败，AH＝0FFH， 否则 ，AH＝00H，CS、DS、ES和SS都是用户定义的选择器 |
| 15   | 90   | 设备等待                                   | AL＝驱动器类型，具体的驱动器类型定义如下： ＝00H~7FH——串行再重用设备 ＝80H~0BFH——可重入式设备 ＝0C0H~0FFH——等待访问设备，没有自检功能 00h — 磁盘 02h — 键盘 80h — 网络 FDh — 软盘马达启动01h — 软盘 03h — 点设备(Pointing Device) FCh — 硬盘复位 FEh — 打印机 ES:BX＝对驱动器类型80H~0FFH的请求块地址 | 操作失败， 否则，AH＝00H                                     |
| 15   | 91   | 设备加电自检                               | AL＝00H~7FH——串行再重用设备 ＝80H~0BFH——可重入式设备         | AH＝00H                                                      |
| 15   | C0   | 读取系统环境                               |                                                              | 入口参数：AH＝0C0H 出口参数： ES:BX＝配置表地址， 配置表的定义如下： 偏移量含义说明 00h-01h表的大小(字节数) 02h系统模型 03h系统子模型 04hBIOS版本号 05h配置标志，其各位为1时的说明如下： 位7—DMA通道3使用 位6—存在从属8259 位5—实时时钟有效 位4—键盘截听有效 位3—等待外部事件有效 位2—扩展BIOS数据区 位1—微通道设施 位0—保留 06h-09h保留 |
| 15   | C1   | 读取扩展BIOS数据区地址(仅在PS/2中有效)     |                                                              |                                                              |
| 15   | C2   | 鼠标图形(仅在PS/2中有效)                   |                                                              |                                                              |
| 15   | C3   | 设置WatcHdog超时(仅在PS/2中有效)           |                                                              |                                                              |
| 15   | C4   | 可编程选项选择，仅在PS/2中有效             |                                                              |                                                              |
| 16   | 0    | 从键盘读字符                               |                                                              | AL=字符码(ASCII码) AH=扫描码                                 |
| 16   | 10   | 从键盘读字符(扩展)                         | 根据0000:0496H单元的内容判断：扩展键盘是否有效               | AL=字符码(ASCII码) AH=扫描码                                 |
| 16   | 1    | 读键盘缓冲区字符                           |                                                              | ZF=0 AL=字符码(ASCII码)    AH=扫描码 ZF=1 缓冲区空           |
| 16   | 11   | 读键盘缓冲区字符(扩展)                     | 根据0000:0496H单元的内容判断：扩展键盘是否有效               | ZF=0 AL=字符码(ASCII码) AH=扫描码 ZF=1 缓冲区空              |
| 16   | 2    | 读键盘状态字节                             |                                                              | AL=键盘状态字节AL＝键盘标志(02H和12H都有效)， 其各位之值为1时的含义如下： 位7—INS开状态 位3—ALT键按下 位6—CAPS LOCK开状态 位2—CTRL键按下 位5—NUM LOCK开状态 位1—左SHIFT键按下 位4—SCROLL LOCK开状态 位0—右SHIFT键按下 |
| 16   | 12   | 读键盘状态字节(扩展)                       | 根据0000:0496H单元的内容判断：扩展键盘是否有效               | AL=键盘状态字节AL＝键盘标志， 其各位之值为1时的含义如下： 位7—INS开状态 位3—ALT键按下 位6—CAPS LOCK开状态 位2—CTRL键按下 位5—NUM LOCK开状态 位1—左SHIFT键按下 位4—SCROLL LOCK开状态 位0—右SHIFT键按下AH＝扩展键盘的标志(12H有效)， 其各位之值为1时的含义如下： 位7—SysReq键按下 位3—右ALT键按下 位6—CAPS LOCK键按下 位2—右CTRL键按下 位5—NUM LOCK键按下 位1—左ALT键按下 位4—SCROLL键按下 位0—左CTRL键按下 |
| 16   | 3    | 设置重复率                                 | 对于PC/AT和PS/2： AL＝05H BH＝重复延迟 BL＝重复率 对于PCjr： AL＝00H——装入缺省的速率和延迟 ＝01H——增加初始延迟 ＝02H——重复频率降低一半 ＝03H——增加延迟和降低一半重复频率 ＝04H——关闭键盘重复功能 |                                                              |
| 16   | 4    | 设置键盘点击                               | AL＝00H——关闭键盘点击功能 AL＝01H——打开键盘点击功能          |                                                              |
| 16   | 5    | 字符及其扫描码进栈                         | CH＝字符的描述码 CL＝字符的ASCII码                           | 操作成功，AL＝00H， 否则，AL＝01H                            |
| 17   | 0    | 打印字符 回送状态字节                      | AL=字符 DX=打印机号(0—LPT1，1—LPT2，2—LPT3，……)              | AH=打印机状态字节位7—打印机空闲 位6—打印机响应 位5—无纸 位4—打印机被选 位3—I/O错误 位2—保留 位1—保留 位0—打印机超时 |
| 17   | 1    | 初始化打印机 回送状态字节                  | DX=打印机号(0—LPT1，1—LPT2，2—LPT3，……)                      | AH=打印机状态字节                                            |
| 17   | 2    | 取状态字节                                 | DX=打印机号(0—LPT1，1—LPT2，2—LPT3，……)                      | AH=打印机状态字节                                            |
| 1A   | 0    | 读时钟                                     |                                                              | CH:CL=时:分 DH:DL=秒:1/100秒                                 |
| 1A   | 1    | 置时钟                                     | CH:CL=时:分 DH:DL=秒:1/100秒                                 |                                                              |
| 1A   | 2    | 读实时钟                                   |                                                              | CH:CL=时:分(BCD码格式) DH:DL=秒:1/100秒(BCD码格式)           |
| 1A   | 3    | 设置时间                                   |                                                              |                                                              |
| 1A   | 4    | 读取日期                                   |                                                              | CH＝BCD码格式的世纪 CL＝BCD码格式的年 DH＝BCD码格式的月 DL＝BCD码格式的日 CF＝0——时钟在走，否则，时钟停止 |
| 1A   | 5    | 设置日期                                   | CH＝BCD码格式的世纪 CL＝BCD码格式的年 DH＝BCD码格式的月 DL＝BCD码格式的日 |                                                              |
| 1A   | 6    | 置报警时间                                 | CH:CL=时:分(BCD) DH:DL=秒:1/100秒(BCD)                       | CF＝0——操作成功， 否则，闹钟已设置或时钟已停止               |
| 1A   | 7    | 清除报警(闹钟复位)                         |                                                              |                                                              |
| 1A   | A    | 读取天数计数(仅在PS/2有效)                 |                                                              |                                                              |
| 1A   | B    | 设置天数计数(仅在PS/2有效)                 |                                                              |                                                              |
| 1A   | 80   | 设置声音源信息                             | AL＝声音源 ＝00H——8253可编程计时器，通道2 ＝01H——盒式磁带输入 ＝02H——I/O通道上的"Audio In" ＝03H——声音产生芯片 |                                                              |
