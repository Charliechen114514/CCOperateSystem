# 目录的基本操作：创建，遍历和删除

## 创建：sys_mkdir

在 Linux 中，`mkdir` 函数用于创建目录，它与同名的 `mkdir` 命令在原理上是相同的，区别在于一个是系统调用，另一个是通过系统调用实现的可执行程序。`mkdir` 函数的原型是 `int mkdir(const char *pathname, mode_t mode)`，其中 `pathname` 是待创建目录的路径和名称，`mode` 是新目录的权限。成功返回 0，失败返回 −1。

创建目录涉及到多个步骤，首先要确认待创建的目录在文件系统中不存在，然后为新目录分配一个 inode。接着，为新目录分配一个块，用于存储该目录中的目录项。每个目录都需要包含两个特殊的目录项：“.”（表示当前目录）和“..”（表示父目录）。随后，系统会在父目录中添加一个新目录的目录项。最后，所有这些资源的变更会被同步到硬盘上，以确保数据的持久化。

这个过程的关键是确保目录结构的正确更新，并保证目录的创建是可靠的。

```c
/* Create a directory at pathname, return 0 on success, return -1 on failure */
int32_t sys_mkdir(const char *pathname)
{
    uint8_t rollback_step =
        0; // Used to rollback resource states if an operation fails
    void *io_buf = sys_malloc(SECTOR_SIZE * 2);
    if (!io_buf)
    {
        ccos_printk("sys_mkdir: sys_malloc for io_buf failed\n");
        return -1;
    }

    PathSearchRecordings searched_record;
    k_memset(&searched_record, 0, sizeof(PathSearchRecordings));
    int inode_no = -1;
    inode_no = search_file(pathname, &searched_record);
    if (inode_no != -1)
    { // If a file or directory with the same name exists,
      // return failure
        ccos_printk("sys_mkdir: file or directory %s exist!\n", pathname);
        rollback_step = 1;
        goto rollback;
    }
    else
    { // If not found, check whether the final directory exists or if any
      // intermediate directory is missing
        uint32_t pathname_depth = path_depth_cnt((char *)pathname);
        uint32_t path_searched_depth =
            path_depth_cnt(searched_record.searched_path);
        /* First, check if all directory levels of pathname are accessible,
         * i.e., whether a failure occurred in accessing any intermediate
         * directory
         */
        if (pathname_depth !=
            path_searched_depth)
        { // This means some intermediate directory is
          // missing
            ccos_printk("sys_mkdir: can`t access %s, subpath %s isn't exist\n",
                        pathname, searched_record.searched_path);
            rollback_step = 1;
            goto rollback;
        }
    }

    Dir *parent_dir = searched_record.parent_dir;
    /* The directory name might have a '/' character, so it is better to use
     * searched_record.searched_path directly without '/' */
    char *dirname = k_strrchr(searched_record.searched_path, '/') + 1;

    inode_no = inode_bitmap_alloc(cur_part);
    if (inode_no == -1)
    {
        ccos_printk("sys_mkdir: allocate inode failed\n");
        rollback_step = 1;
        goto rollback;
    }

    Inode new_dir_inode;
    inode_init(inode_no, &new_dir_inode); // Initialize the inode

    uint32_t block_bitmap_idx =
        0; // To record the index of block in block_bitmap
    int32_t block_lba = -1;
    /* Allocate a block for the directory to store '.' and '..' */
    block_lba = block_bitmap_alloc(cur_part);
    if (block_lba == -1)
    {
        ccos_printk("sys_mkdir: block_bitmap_alloc for create directory failed\n");
        rollback_step = 2;
        goto rollback;
    }
    new_dir_inode.i_sectors[0] = block_lba;
    /* Synchronize the bitmap to disk after each block allocation */
    block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
    KERNEL_ASSERT(block_bitmap_idx != 0);
    bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

    /* Write the directory entries for '.' and '..' */
    k_memset(io_buf, 0, SECTOR_SIZE * 2); // Clear io_buf
    DirEntry *p_de = (DirEntry *)io_buf;

    /* Initialize the current directory entry "." */
    k_memcpy(p_de->filename, ".", 1);
    p_de->i_no = inode_no;
    p_de->f_type = FT_DIRECTORY;

    p_de++;
    /* Initialize the parent directory entry ".." */
    k_memcpy(p_de->filename, "..", 2);
    p_de->i_no = parent_dir->inode->i_no;
    p_de->f_type = FT_DIRECTORY;
    ide_write(cur_part->my_disk, new_dir_inode.i_sectors[0], io_buf, 1);

    new_dir_inode.i_size = 2 * cur_part->sb->dir_entry_size;

    /* Add the new directory entry in the parent directory */
    DirEntry new_dir_entry;
    k_memset(&new_dir_entry, 0, sizeof(DirEntry));
    create_dir_entry(dirname, inode_no, FT_DIRECTORY, &new_dir_entry);
    k_memset(io_buf, 0, SECTOR_SIZE * 2); // Clear io_buf
    if (!sync_dir_entry(parent_dir, &new_dir_entry,
                        io_buf))
    { // sync_dir_entry will synchronize the block
      // bitmap to disk
        ccos_printk("sys_mkdir: sync_dir_entry to disk failed!\n");
        rollback_step = 2;
        goto rollback;
    }

    /* Synchronize the inode of the parent directory to disk */
    k_memset(io_buf, 0, SECTOR_SIZE * 2);
    inode_sync(cur_part, parent_dir->inode, io_buf);

    /* Synchronize the inode of the new directory to disk */
    k_memset(io_buf, 0, SECTOR_SIZE * 2);
    inode_sync(cur_part, &new_dir_inode, io_buf);

    /* Synchronize the inode bitmap to disk */
    bitmap_sync(cur_part, inode_no, INODE_BITMAP);

    sys_free(io_buf);

    /* Close the parent directory of the newly created directory */
    dir_close(searched_record.parent_dir);
    return 0;

/* When creating a file or directory, multiple resources need to be created,
  if any step fails, the following rollback steps will be executed */
rollback: // Rollback due to failure at some step
    switch (rollback_step)
    {
    case 2:
        bitmap_set(&cur_part->inode_bitmap, inode_no,
                   0); // If the inode creation for the new directory fails,
                       // restore the previously allocated inode
        goto DIR_CLOSE;
        break;
    case 1:
    DIR_CLOSE:
        /* Close the parent directory of the newly created directory */
        dir_close(searched_record.parent_dir);
        break;
    }
    sys_free(io_buf);
    return -1;
}
```

**内存分配**：函数开始时分配了一块大小为 `SECTOR_SIZE * 2` 的内存 `io_buf`，用于存放目录的内容。如果内存分配失败，则输出错误信息并返回 -1。

**路径查找**：使用 `search_file` 函数查找指定路径 `pathname` 是否已经存在相同的文件或目录。如果文件或目录已经存在，函数会输出错误信息并进行回滚，返回 -1。

**路径深度检查**：如果文件或目录不存在，函数继续检查路径的完整性。它比较传入路径 `pathname` 的深度和当前已搜索路径的深度，确保路径中每个父目录都存在。如果某个中间目录不存在，输出错误信息并进行回滚，返回 -1。

**分配 inode**：如果路径检查通过，函数为新目录分配一个 inode（索引节点）。如果分配失败，输出错误信息并进行回滚，返回 -1。

**分配数据块**：接下来，为新目录分配一个数据块，这个数据块用于存放当前目录 `.` 和父目录 `..` 的目录项。如果分配失败，输出错误信息并进行回滚，返回 -1。

**写入目录项**：为新目录写入两个特殊的目录项：当前目录 `.` 和父目录 `..`。目录项的格式包括文件名、inode 编号和文件类型（目录）。这些目录项写入到新分配的数据块中。

**在父目录中添加目录项**：接下来，创建一个新的目录项，在父目录中添加对新目录的引用。函数调用 `sync_dir_entry` 来同步父目录的数据块和目录项，如果失败，输出错误信息并进行回滚，返回 -1。

**同步 inode 到磁盘**：同步父目录和新目录的 inode 到磁盘，确保文件系统的元数据与实际数据保持一致。

**同步 inode 位图**：同步 inode 位图到磁盘，以便更新系统的 inode 使用状态。

**清理操作**：在成功创建目录后，释放内存并关闭父目录，返回 0 表示成功。

**回滚操作**：如果在上述过程中有任何一步失败，系统会根据失败的步骤回滚之前的操作。回滚步骤包括：

- 如果分配 inode 失败，恢复之前分配的 inode。
- 如果数据块分配失败，恢复之前的操作，并关闭父目录。

## 遍历目录

```c
/* Opens the directory specified by name, returns a directory pointer on
   success, returns NULL on failure */
Dir *sys_opendir(const char *name)
{
    KERNEL_ASSERT(strlen(name) < MAX_PATH_LEN);
    /* If it's the root directory '/', directly return &root_dir */
    if (name[0] == '/' && (name[1] == 0 || name[0] == '.'))
    {
        return &root_dir;
    }

    /* Check if the directory to be opened exists */
    PathSearchRecordings searched_record;
    k_memset(&searched_record, 0, sizeof(PathSearchRecordings));
    int inode_no = search_file(name, &searched_record);
    Dir *ret = NULL;
    if (inode_no ==
        -1)
    { // If the directory is not found, print an error message
        ccos_printk("In %s, sub path %s not exist\n", name,
                    searched_record.searched_path);
    }
    else
    {
        if (searched_record.file_type == FT_REGULAR)
        {
            ccos_printk("%s is regular file!\n", name);
        }
        else if (searched_record.file_type == FT_DIRECTORY)
        {
            ret = dir_open(cur_part, inode_no);
        }
    }
    dir_close(searched_record.parent_dir);
    return ret;
}

/* Closes the directory dir, returns 0 on success, returns -1 on failure */
int32_t sys_closedir(Dir *dir)
{
    int32_t ret = -1;
    if (dir)
    {
        dir_close(dir);
        ret = 0;
    }
    return ret;
}

/* Reads one directory entry from the directory dir, returns the directory entry
   address on success, returns NULL at the end of the directory or on error */
DirEntry *sys_readdir(Dir *dir) {
    KERNEL_ASSERT(dir);
    return dir_read(dir);
}
```

​	这段代码包含了三个文件系统相关的函数，用于打开、关闭和读取目录。`sys_opendir`用于打开一个目录并返回该目录的指针。首先，它会检查传入的路径名是否有效（长度不超过 `MAX_PATH_LEN`）。如果路径是根目录 `'/'` 或者是当前目录 `'.'`，它直接返回根目录指针 `&root_dir`。否则，调用 `search_file` 函数检查指定的目录是否存在。如果目录不存在，它会打印错误信息；如果找到该目录且它是一个常规文件（`FT_REGULAR`），则会提示错误信息，说明不能将文件作为目录打开；如果是一个目录（`FT_DIRECTORY`），则会调用 `dir_open` 打开该目录并返回相应的目录指针。最后，函数关闭搜索到的父目录（`searched_record.parent_dir`）并返回打开的目录指针（`ret`），如果失败返回 `NULL`。`sys_closedir`用于关闭一个已经打开的目录。它接收一个目录指针 `dir` 作为参数，如果该指针不为 `NULL`，则调用 `dir_close` 关闭目录并返回成功的状态；否则，返回 `-1`。`sys_readdir`用于从目录中读取一个目录项。它接收一个目录指针 `dir` 作为参数，调用 `dir_read` 函数读取目录项，并返回目录项的地址。如果到达目录末尾或者发生错误，返回 `NULL`。

​	我们下面来看看dir_read:

```c
/*
 * Reads a directory entry from the specified directory.
 *
 * Parameters:
 * dir - Pointer to the directory structure to read from.
 *
 * This function iterates over the blocks of the directory,
 * reading the next valid entry. It skips empty blocks and
 * invalid entries while updating the directory's read position.
 *
 * Return:
 * Pointer to a valid directory entry if successful.
 * NULL if no more entries are found or an error occurs.
 */
DirEntry *dir_read(Dir *dir)
{
    DirEntry *dir_e = (DirEntry *)dir->dir_buf;
    Inode *dir_inode = dir->inode;
    uint32_t all_blocks[140] = {0}, block_cnt = 12;
    uint32_t block_idx = 0, dir_entry_idx = 0;

    /* Collect all direct block addresses */
    while (block_idx < 12)
    {
        all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
        block_idx++;
    }

    /* If there are indirect blocks, read them */
    if (dir_inode->i_sectors[12] != 0)
    {
        ide_read(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12,
                 1);
        block_cnt = 140;
    }
    block_idx = 0;

    uint32_t cur_dir_entry_pos = 0;
    uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
    uint32_t dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;

    /* Iterate over all blocks to find a valid directory entry */
    while (block_idx < block_cnt)
    {
        if (dir->dir_pos >= dir_inode->i_size)
        {
            return NULL;
        }

        if (all_blocks[block_idx] == 0)
        {
            block_idx++;
            continue;
        }

        k_memset(dir_e, 0, SECTOR_SIZE);
        ide_read(cur_part->my_disk, all_blocks[block_idx], dir_e, 1);
        dir_entry_idx = 0;

        /* Traverse all entries in the current block */
        while (dir_entry_idx < dir_entrys_per_sec)
        {
            if ((dir_e + dir_entry_idx)->f_type)
            {
                if (cur_dir_entry_pos < dir->dir_pos)
                {
                    cur_dir_entry_pos += dir_entry_size;
                    dir_entry_idx++;
                    continue;
                }

                KERNEL_ASSERT(cur_dir_entry_pos == dir->dir_pos);
                dir->dir_pos += dir_entry_size;
                return dir_e + dir_entry_idx;
            }
            dir_entry_idx++;
        }
        block_idx++;
    }

    return NULL;
}

```

这段代码定义了一个函数 `dir_read`，它用于从指定的目录中读取一个目录项。函数首先初始化一些变量和缓冲区，准备读取目录的所有块。`all_blocks` 数组保存了该目录的所有直接块地址，最多可以存储 140 个块的地址。目录的直接块（最多 12 个）首先被加载到 `all_blocks` 中。如果该目录有间接块（第 13 个块），则会读取这些间接块，并将块地址存储在 `all_blocks` 中。

接着，函数开始遍历所有的块，读取每个块中的目录项。每个目录项的大小由文件系统的超级块中的 `dir_entry_size` 决定，且每个扇区内可以存储多个目录项。`dir_entry_idx` 变量用于遍历当前块中的所有目录项。每当遇到一个有效的目录项（`f_type` 非零），它会检查是否跳过当前目录项（根据 `dir->dir_pos` 来决定）。如果跳过的目录项数目小于 `dir->dir_pos`，就继续跳过当前目录项直到到达目标位置。

当到达 `dir->dir_pos` 时，函数更新该位置并返回该目录项。如果没有找到有效的目录项，或者已经遍历完所有块，函数返回 `NULL`，表示没有更多的目录项可供读取。

## 删除目录

​	删除目录，要保证目录是空的！

```c
/*
 * Checks if a directory is empty.
 *
 * Parameters:
 * dir - Pointer to the directory to check.
 *
 * A directory is considered empty if it contains only the
 * entries for "." and "..".
 *
 * Return:
 * true  - Directory is empty.
 * false - Directory contains other entries.
 */
bool dir_is_empty(Dir *dir)
{
    Inode *dir_inode = dir->inode;
    return (dir_inode->i_size == cur_part->sb->dir_entry_size * 2);
}
```

​	若目录的大小等于2 个目录项的大小，就表示该目录为空。（因为只有.和..嘛！）

```c
/*
 * Removes a subdirectory from its parent directory.
 *
 * Parameters:
 * parent_dir - Pointer to the parent directory structure.
 * child_dir  - Pointer to the child directory structure to be removed.
 *
 * This function ensures that the child directory is empty and
 * safely deletes it by:
 * 1. Removing its entry from the parent directory.
 * 2. Releasing all blocks and the inode associated with the child directory.
 *
 * Return:
 * 0  - Directory was successfully removed.
 * -1 - Directory removal failed (e.g., memory allocation error).
 */
int32_t dir_remove(Dir *parent_dir, Dir *child_dir)
{
    Inode *child_dir_inode = child_dir->inode;

    /* Verify that the directory has no extra blocks beyond the first one */
    int32_t block_idx = 1;
    while (block_idx < 13)
    {
        KERNEL_ASSERT(child_dir_inode->i_sectors[block_idx] == 0);
        block_idx++;
    }

    void *io_buf = sys_malloc(SECTOR_SIZE * 2);
    if (!io_buf)
    {
        ccos_printk("dir_remove: malloc for io_buf failed\n");
        return -1;
    }

    /* Remove the directory entry in the parent directory */
    delete_dir_entry(cur_part, parent_dir, child_dir_inode->i_no, io_buf);

    /* Release the blocks and inode associated with the child directory */
    inode_release(cur_part, child_dir_inode->i_no);

    sys_free(io_buf);
    return 0;
}

```

 `dir_remove` 函数的主要功能是从父目录中删除一个子目录。首先，它通过检查子目录的 inode，确保该子目录没有超过一个块的内容。具体来说，函数检查子目录的 inode 的 `i_sectors` 数组中的块，从索引 1 开始，确保没有其他块（即只能有一个块，索引 0）。如果满足条件，接下来会分配一个用于操作的缓冲区 `io_buf`，大小为两个扇区。若分配失败，则返回 -1，表示删除失败。

接下来，函数会从父目录中删除该子目录的目录项，调用 `delete_dir_entry` 函数完成该操作，传入当前磁盘和父目录结构，及子目录 inode 的编号。最后，函数会释放子目录占用的块和 inode 资源，调用 `inode_release` 完成释放操作。释放完资源后，释放分配的缓冲区并返回 0，表示目录成功删除。如果某个操作失败（例如内存分配失败），则返回 -1，表示删除失败。

​	sys_rmdir则是真正的完成这个事情。

```
/* Deletes an empty directory, returns 0 on success, returns -1 on failure */
int32_t sys_rmdir(const char *pathname) {
    /* Check if the directory to be deleted exists */
    PathSearchRecordings searched_record;
    k_memset(&searched_record, 0, sizeof(PathSearchRecordings));
    int32_t inode_no = search_file(pathname, &searched_record);
    KERNEL_ASSERT(inode_no != 0);
    int32_t retval = -1; // Default return value
    if (inode_no == -1) {
        ccos_printk("In %s, sub path %s not exist\n", pathname,
               searched_record.searched_path);
    } else {
        if (searched_record.file_type == FT_REGULAR) {
            ccos_printk("%s is regular file!\n", pathname);
        } else {
            Dir *dir = dir_open(cur_part, inode_no);
            if (!dir_is_empty(dir)) { // Non-empty directory cannot be deleted
                ccos_printk("dir %s is not empty, it is not allowed to delete a "
                       "nonempty directory!\n",
                       pathname);
            } else {
                if (!dir_remove(searched_record.parent_dir, dir)) {
                    retval = 0;
                }
            }
            dir_close(dir);
        }
    }
    dir_close(searched_record.parent_dir);
    return retval;
}
```

这段代码实现了 `sys_rmdir` 函数，用于删除一个空目录。首先，它检查指定路径的目录是否存在。通过调用 `search_file` 查找目录，并使用 `PathSearchRecordings` 记录相关信息。如果找不到目录（返回值为 -1），则打印错误信息并返回 -1。

如果目录存在，接下来判断该路径是常规文件还是目录。如果是常规文件（`FT_REGULAR`），则不能删除，打印提示信息并返回 -1。如果是目录，则继续检查该目录是否为空，使用 `dir_is_empty` 函数进行判断。如果目录非空，打印错误信息，提示不能删除非空目录；如果目录为空，则调用 `dir_remove` 删除该目录。

最后，无论删除操作是否成功，都关闭目录指针，并返回相应的状态值。删除成功时返回 0，失败时返回 -1。

## 上电测试

```c
int main(void)
{
    init_all();
    Dir *p_dir = sys_opendir("/dir1/subdir1");
    if (p_dir)
    {
        printf("/dir1/subdir1 open done!\ncontent:\n");
        char *type = NULL;
        DirEntry*dir_e = NULL;
        while ((dir_e = sys_readdir(p_dir)))
        {
            if (dir_e->f_type == FT_REGULAR)
            {
                type = "regular";
            }
            else
            {
                type = "directory";
            }
            printf("      %s   %s\n", type, dir_e->filename);
        }
        if (sys_closedir(p_dir) == 0)
        {
            printf("/dir1/subdir1 close done!\n");
        }
        else
        {
            printf("/dir1/subdir1 close fail!\n");
        }
    }
    else
    {
        printf("/dir1/subdir1 open fail!\n");
    }
    while (1)
        ;
    return 0;
}
```

![image-20250309233514621](./13.8_dirent_op/image-20250309233514621.png)