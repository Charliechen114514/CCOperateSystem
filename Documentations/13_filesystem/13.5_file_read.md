# 文件读

```c
/* Reads 'count' bytes from the file into 'buf' and returns the number of bytes
   read. Returns -1 if the end of the file is reached. */
int32_t file_read(File *file, void *buf, uint32_t count) {
    uint8_t *buf_dst = (uint8_t *)buf;
    uint32_t size = count, size_left = size;

    /* If the requested number of bytes exceeds the file's readable size,
       use the remaining size as the number of bytes to read. */
    if ((file->fd_pos + count) > file->fd_inode->i_size) {
        size = file->fd_inode->i_size - file->fd_pos;
        size_left = size;
        if (size == 0) { // Return -1 if the end of the file is reached
            return -1;
        }
    }

    uint8_t *io_buf =
        sys_malloc(BLOCK_SIZE); // Allocate buffer for I/O operations
    if (!io_buf) {
        ccos_printk("file_read: sys_malloc for io_buf failed\n");
    }
    uint32_t *all_blocks = (uint32_t *)sys_malloc(
        BLOCK_SIZE + 48); // Allocate space to store the addresses of all blocks
                          // used by the file
    if (!all_blocks ) {
        ccos_printk("file_read: sys_malloc for all_blocks failed\n");
        return -1;
    }

    uint32_t block_read_start_idx =
        file->fd_pos / BLOCK_SIZE; // Start block index of the data to be read
    uint32_t block_read_end_idx =
        (file->fd_pos + size) /
        BLOCK_SIZE; // End block index of the data to be read
    uint32_t read_blocks = block_read_start_idx -
                           block_read_end_idx; // If the difference is 0, data
                                               // is within the same sector
    KERNEL_ASSERT(block_read_start_idx < 139 && block_read_end_idx < 139);

    int32_t indirect_block_table; // To store the address of the indirect block
                                  // table
    uint32_t block_idx;           // To store the block address to be read

    /* Start constructing the 'all_blocks' array, which stores the block
     * addresses used by the file. */
    if (read_blocks ==
        0) { // Data is within the same sector, no need to read across sectors
        KERNEL_ASSERT(block_read_end_idx == block_read_start_idx);
        if (block_read_end_idx <
            12) { // If the data is within the first 12 direct blocks
            block_idx = block_read_end_idx;
            all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
        } else { // If indirect block table is used, read the table into memory
            indirect_block_table = file->fd_inode->i_sectors[12];
            ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12,
                     1);
        }
    } else { // Multiple blocks need to be read
             /* First case: Start and end blocks are within direct blocks */
        if (block_read_end_idx <
            12) { // If the data ends within the direct blocks
            block_idx = block_read_start_idx;
            while (block_idx <= block_read_end_idx) {
                all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
                block_idx++;
            }
        } else if (block_read_start_idx < 12 && block_read_end_idx >= 12) {
            /* Second case: Data spans direct and indirect blocks */
            /* First, copy the direct block addresses into 'all_blocks' */
            block_idx = block_read_start_idx;
            while (block_idx < 12) {
                all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
                block_idx++;
            }
            KERNEL_ASSERT(
                file->fd_inode->i_sectors[12] !=
                0); // Ensure that the indirect block table has been allocated

            /* Then, copy the indirect block addresses into 'all_blocks' */
            indirect_block_table = file->fd_inode->i_sectors[12];
            ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12,
                     1); // Read the indirect block table into the memory
                         // starting from the 13th block
        } else {
            /* Third case: Data is entirely within the indirect blocks */
            KERNEL_ASSERT(
                file->fd_inode->i_sectors[12] !=
                0); // Ensure that the indirect block table has been allocated
            indirect_block_table =
                file->fd_inode->i_sectors[12]; // Get the address of the
                                               // indirect block table
            ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12,
                     1); // Read the indirect block table into the memory
                         // starting from the 13th block
        }
    }

    /* The addresses of the required blocks are now stored in 'all_blocks'.
     * Start reading the data. */
    uint32_t sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;
    uint32_t bytes_read = 0;
    while (bytes_read < size) { // Continue reading until all data is read
        sec_idx = file->fd_pos / BLOCK_SIZE;
        sec_lba = all_blocks[sec_idx]; // Get the logical block address
        sec_off_bytes =
            file->fd_pos % BLOCK_SIZE; // Get the offset within the block
        sec_left_bytes =
            BLOCK_SIZE - sec_off_bytes; // Get the remaining bytes in the block
        chunk_size = size_left < sec_left_bytes
                         ? size_left
                         : sec_left_bytes; // Determine the chunk size to read

        k_memset(io_buf, 0, BLOCK_SIZE); // Clear the I/O buffer
        ide_read(cur_part->my_disk, sec_lba, io_buf,
                 1); // Read the block from disk
        k_memcpy(buf_dst, io_buf + sec_off_bytes,
               chunk_size); // Copy the relevant data into the buffer

        buf_dst += chunk_size;      // Update the destination pointer
        file->fd_pos += chunk_size; // Update the file position
        bytes_read += chunk_size;   // Update the number of bytes read
        size_left -= chunk_size;    // Update the remaining bytes to be read
    }

    sys_free(all_blocks); // Free the block addresses array
    sys_free(io_buf);     // Free the I/O buffer
    return bytes_read;    // Return the number of bytes successfully read
}
```

`file_read` 函数从文件中读取指定数量的字节并将其存储在 `buf` 中，返回成功读取的字节数。如果读取到文件末尾，返回 `-1`。函数首先将目标缓冲区 `buf` 转换为 `uint8_t *` 类型的指针 `buf_dst`，并使用 `size` 变量表示请求读取的字节数，`size_left` 跟踪剩余要读取的字节。如果请求的字节数加上当前文件的读位置超出了文件大小，则将读取的字节数限制为文件剩余的字节数。如果文件已经读取完毕，则返回 `-1`。接着，函数为 I/O 操作分配缓冲区 `io_buf` 和存储文件所有块地址的数组 `all_blocks`。计算文件读取的开始和结束块的索引，确定读取数据的方式。如果数据只在同一个块内，则直接读取该块；如果数据跨越直接块和间接块，则先读取直接块，再读取间接块；如果数据完全在间接块内，则直接读取间接块。然后，从所有相关的块中读取数据，每次读取时，将数据存储到 `buf_dst` 中，并更新文件指针 `fd_pos` 和已读取字节数 `bytes_read`。读取完毕后，释放分配的内存（`all_blocks` 和 `io_buf`）。最后，返回成功读取的字节数 `bytes_read`。

​	我们相应的实现sys_read：

```c
/* Read count bytes from the file pointed to by file descriptor fd into buf,
 * return the number of bytes read on success, return -1 if end of file is
 * reached
 */
int32_t sys_read(int32_t fd, void *buf, uint32_t count) {
    
    if (fd < 0 || fd == stdout_no || fd == stderr_no) {
        ccos_printk("sys_read: fd error\n");
    }
    KERNEL_ASSERT(buf);
    uint32_t _fd = fd_local2global(fd); 
    return file_read(&file_table[_fd], buf, count); 
}
```

`sys_read` 函数从文件描述符指向的文件中读取指定数量的字节到 `buf` 中。首先检查传入的文件描述符 `fd` 是否有效，确保它不是标准输出或标准错误流。如果文件描述符无效，则打印错误信息。然后，使用 `KERNEL_ASSERT` 确保 `buf` 指针不为空。接着，通过 `fd_local2global` 将本地文件描述符转换为全局文件描述符 `_fd`，并调用 `file_read` 函数从文件中读取数据，返回读取的字节数。如果读取过程中遇到文件末尾，`file_read` 会返回 `-1`。

## 上电现象

```c
#include "include/device/console_tty.h"
#include "include/kernel/init.h"
#include "include/library/kernel_assert.h"
#include "include/thread/thread.h"
#include "include/user/stdio/stdio.h"
#include "include/memory/memory.h"
#include "include/library/ccos_print.h"
#include "include/filesystem/filesystem.h"
#include "include/library/string.h"

int main(void) { 
    init_all();
    uint32_t fd = sys_open("/file1", O_RDWR); 
    printf("open /file1,fd:%d\n", fd); 
    char buf[64] = {0}; 
    int read_bytes = sys_read(fd, buf, 18); 
    printf("1_ read %d bytes:\n%s\n", read_bytes, buf); 

    k_memset(buf, 0, 64); 
    read_bytes = sys_read(fd, buf, 6); 
    printf("2_ read %d bytes:\n%s", read_bytes, buf); 

    k_memset(buf, 0, 64); 
    read_bytes = sys_read(fd, buf, 6); 
    printf("3_ read %d bytes:\n%s", read_bytes, buf); 

    printf("________  close file1 and reopen  ________\n"); 
    sys_close(fd); 
    fd = sys_open("/file1", O_RDWR); 
    k_memset(buf, 0, 64); 
    read_bytes = sys_read(fd, buf, 24); 
    printf("4_ read %d bytes:\n%s", read_bytes, buf); 

    sys_close(fd); 
    while(1); 
    return 0; 
}
```

![image-20250309231432594](./13.5_file_read/image-20250309231432594.png)