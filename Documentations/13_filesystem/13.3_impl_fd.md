# 说说文件描述符与常见的操作

> ⚠：从本章开始代码存在问题，但是我没有找到，所以谨慎参考！

在 Linux 系统中，文件操作都是基于文件描述符的。文件描述符用于描述与文件操作相关的对象，它本质上是一个整数，标识进程操作文件时所用的资源。虽然文件本身由 inode 描述，但 inode 主要用于存储文件的相关信息（如存储位置和权限），与文件操作并不直接相关。文件描述符与 inode 的主要区别在于，文件描述符更关注文件的操作过程，而 inode 主要关心文件的存储和元数据。

在 Linux 中，打开文件的过程不仅涉及找到文件的 inode 位置，还需要为文件创建一个文件结构（file structure）。每当文件被打开时，系统会为文件创建一个文件结构，该结构记录了文件的操作偏移量等信息。即便是同一个文件被多个进程同时打开，每个进程也会有独立的文件结构，它们之间的偏移量互不影响。文件结构存储在一个称为文件表（file table）的数组中。文件表是全局管理的，而每个进程都有一个独立的文件描述符数组，该数组指向文件表中的文件结构。

当通过 `open` 函数打开文件时，系统返回一个文件描述符，这个文件描述符其实是该进程文件描述符数组中的一个下标。该下标并不表示文件的数量，而是指向文件表中的文件结构。每个文件描述符数组和文件表都由操作系统为每个进程单独维护。文件描述符数组包含了标准的文件描述符，如 0 代表标准输入，1 代表标准输出，2 代表标准错误输出。

文件描述符与文件操作的关系比较直观。操作系统通过文件描述符查找文件数据块的过程涉及多个数据结构，包括进程控制块（PCB）中的文件描述符数组、文件表和 inode 队列。通过文件描述符，操作系统可以定位到文件表中的对应文件结构，再从文件结构中获取文件的 inode，最终找到文件的数据块。



![image-20250309220245615](./13.3_impl_fd/image-20250309220245615.png)

​	我们下面给进程塞上文件描述符表先：

```c
/**
 * @brief Process Control Block (PCB) structure for threads and processes.
 *
 * This structure stores the execution context, scheduling information,
 * and resources associated with a thread or process.
 */
typedef struct {
    uint32_t *self_kstack;         // Pointer to the kernel stack of the thread
    pid_t pid;                     // Process ID
    TaskStatus status;             // Current status of the thread
    char name[TASK_NAME_ARRAY_SZ]; // Name of the thread
    uint8_t priority;              // Thread priority level
    uint8_t ticks;                 // Time slices allocated per execution cycle
    uint32_t elapsed_ticks;        // Total CPU time consumed

    /**
     * @brief General list element for scheduling queues.
     *
     * Used to manage the thread in general scheduling queues.
     */
    list_elem general_tag;

    /**
     * @brief List element for all threads.
     *
     * Used to track all threads in the system.
     */
    list_elem all_list_tag;

    uint32_t *pg_dir; // Virtual address of process page directory
    VirtualMemoryHandle userprog_vaddr; // User process virtual memory space
    MemoryBlockDescriptor
        u_block_desc[DESC_CNT]; // User process memory block descriptors
    int32_t
        fd_table[MAX_FILES_OPEN_PER_PROC]; // File descriptors of opened files
    uint32_t stack_magic;  // Stack boundary marker for overflow detection
} TaskStruct;
```

​	我们还需要完成初始化：

```c
static void init_fd_table(TaskStruct *pthread){
    for(uint8_t i = 0; i < 3; i++){
        pthread->fd_table[i] = i;
    }
    uint8_t fd_idx = 3;
    while (fd_idx < MAX_FILES_OPEN_PER_PROC) { 
        pthread->fd_table[fd_idx] = -1;
        fd_idx++;
    }
}

/* Initialize basic thread information */
void init_thread(TaskStruct *pthread, char *name, int prio) {
    k_memset(pthread, 0, sizeof(*pthread));
    pthread->pid = allocate_pid(); // Assign a new pid
    k_strcpy(pthread->name, name);

    if (pthread == main_thread) {
        /* Main thread is set to TASK_RUNNING since it's always running */
        pthread->status = TASK_RUNNING;
    } else {
        pthread->status = TASK_READY;
    }

    /* Initialize the thread's kernel stack */
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE);
    pthread->priority = prio;
    pthread->ticks = prio; // Set the number of ticks based on priority
    pthread->elapsed_ticks = 0;
    pthread->pg_dir = NULL;

    init_fd_table(pthread);

    pthread->stack_magic =
        TASK_MAGIC; // Custom magic number for stack validation
}
```

## 对inode完成操作

​	我们先录inode 所在的扇区地址及在扇区内的偏移量

```
/* Structure to store the inode location */
typedef struct  {
   bool	 two_sec;	// Indicates if the inode spans two sectors
   uint32_t sec_lba;	// The sector number where the inode is located
   uint32_t off_size;	// The byte offset of the inode within the sector
}InodePosition;
```

`InodePosition` 结构体用于存储 inode 的位置。它包含了三个成员。`two_sec` 用来标记 inode 是否跨越了两个扇区。`sec_lba` 是该 inode 所在扇区的逻辑块地址，用于定位 inode 所在的磁盘扇区。`off_size` 表示 inode 在该扇区内的偏移量，确保能够准确找到 inode 的数据。这个结构体有助于文件系统定位 inode，并在磁盘上正确访问它。

```c
/* Locate the sector and offset where the inode is located */
static void inode_locate(DiskPartition* part, uint32_t inode_no, InodePosition* inode_pos) {
    /* The inode table is contiguous on the disk */
    KERNEL_ASSERT(inode_no < 4096);
    uint32_t inode_table_lba = part->sb->inode_table_lba;
 
    uint32_t inode_size = sizeof(Inode);
    uint32_t off_size = inode_no * inode_size;	    // The byte offset of inode_no within the inode table
    uint32_t off_sec  = off_size / 512;		    // The sector offset of inode_no within the inode table
    uint32_t off_size_in_sec = off_size % 512;	    // The start address of the inode within the sector
 
    /* Check if the inode spans across two sectors */
    uint32_t left_in_sec = 512 - off_size_in_sec;
    if (left_in_sec < inode_size ) {	// If the remaining space in the sector is insufficient to hold the inode, it spans two sectors
       inode_pos->two_sec = true;
    } else {				  // Otherwise, the inode fits within a single sector
       inode_pos->two_sec = false;
    }
    inode_pos->sec_lba = inode_table_lba + off_sec;
    inode_pos->off_size = off_size_in_sec;
 }
 
 /* Synchronize the inode to the disk partition */
 void inode_sync(DiskPartition* part, Inode* inode, void* io_buf) {	 // io_buf is the buffer for disk IO
    uint8_t inode_no = inode->i_no;
    InodePosition inode_pos;
    inode_locate(part, inode_no, &inode_pos);	       // The inode position is stored in inode_pos
    KERNEL_ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
    
    /* Members inode_tag and i_open_cnts in the inode are not needed on the disk,
     * They are used in memory for tracking list positions and shared processes */
    Inode pure_inode;
    k_memcpy(&pure_inode, inode, sizeof(Inode));
 
    /* These three members only exist in memory, we need to clear them before synchronizing the inode to disk */
    pure_inode.i_open_cnts = 0;
    pure_inode.write_deny = false;	 // Set to false to ensure it is writable when read from disk
    pure_inode.inode_tag.prev = pure_inode.inode_tag.next = NULL;
 
    char* inode_buf = (char*)io_buf;
    if (inode_pos.two_sec) {	    // If the inode spans two sectors, read and write two sectors
       ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// Read two sectors since the inode was written continuously during formatting
 
    /* Start writing the inode into the two sectors at the appropriate positions */
       k_memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(Inode));
    
    /* Write the modified data back to disk */
       ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
    } else {			    // If it's just one sector
       ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
       k_memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(Inode));
       ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
    }
 }
```

`inode_locate` 函数用于定位一个 inode 在磁盘分区中的扇区和偏移量。首先，它通过计算 inode 在 inode 表中的偏移量和所在扇区来确定位置。如果该 inode 跨越两个扇区，`two_sec` 会被设置为 `true`，否则设置为 `false`。函数根据这些信息计算出 inode 所在的扇区号（`sec_lba`）和在该扇区中的偏移量（`off_size`）。

`inode_sync` 函数用于将 inode 同步到磁盘上的指定分区。首先，它调用 `inode_locate` 函数来获取 inode 的位置。然后，它将 inode 中的必要数据复制到一个临时结构体 `pure_inode` 中，并清除掉一些在磁盘中不需要的字段。接着，判断该 inode 是否跨越两个扇区，如果是，则读取两个扇区的数据，修改其中相应的 inode 部分，然后将修改后的数据写回到这两个扇区。如果 inode 仅占用一个扇区，则只需读取和写入一个扇区。通过这种方式，inode 数据被同步到磁盘分区中的相应位置。

```c
/* Open the inode corresponding to the inode number */
Inode* inode_open(DiskPartition* part, uint32_t inode_no) {
    /* First, try to find the inode in the opened inode list for faster access */
    list_elem* elem = part->open_inodes.head.next;
    Inode* inode_found;
    while (elem != &part->open_inodes.tail) {
       inode_found = elem2entry(Inode, inode_tag, elem);
       if (inode_found->i_no == inode_no) {
      inode_found->i_open_cnts++;
      return inode_found;
       }
       elem = elem->next;
    }
 
    /* If the inode is not found in the opened list, read it from the disk and add it to the list */
    InodePosition inode_pos;
 
    /* The inode location information will be stored in inode_pos, including the sector address and byte offset */
    inode_locate(part, inode_no, &inode_pos);
 
    /* To ensure that the inode created by sys_malloc is shared by all tasks,
     * it needs to be placed in kernel space, so temporarily set cur_pbc->pg_dir to NULL */
    TaskStruct* cur = current_thread();
    uint32_t* cur_pagedir_bak = cur->pg_dir;
    cur->pg_dir = NULL;
    /* After these three lines of code, the following memory allocation will be in kernel space */
    inode_found = (Inode*)sys_malloc(sizeof(Inode));
    /* Restore pg_dir */
    cur->pg_dir = cur_pagedir_bak;
 
    char* inode_buf;
    if (inode_pos.two_sec) {	// Handle the case where the inode spans two sectors
       inode_buf = (char*)sys_malloc(1024);
 
    /* The inode table is written continuously by partition_format, so we can read it consecutively */
       ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
    } else {	// Otherwise, the inode does not span sectors, so a single sector buffer is enough
       inode_buf = (char*)sys_malloc(512);
       ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
    }
    k_memcpy(inode_found, inode_buf + inode_pos.off_size, sizeof(Inode));
 
    /* Since this inode is likely to be used soon, insert it at the head of the list for quick retrieval */
    list_push(&part->open_inodes, &inode_found->inode_tag);
    inode_found->i_open_cnts = 1;
 
    sys_free(inode_buf);
    return inode_found;
 }
 
 /* Close the inode or decrement its open count */
 void inode_close(Inode* inode) {
    /* If no processes are using the inode anymore, remove it from the list and free the memory */
    Interrupt_Status old_status = set_intr_status(INTR_OFF);
    if (--inode->i_open_cnts == 0) {
       list_remove(&inode->inode_tag);	  // Remove the inode from part->open_inodes
 
    /* The inode was allocated in kernel space via sys_malloc when opened,
       so free the inode's memory in kernel space */
       TaskStruct* cur = current_thread();
       uint32_t* cur_pagedir_bak = cur->pg_dir;
       cur->pg_dir = NULL;
       sys_free(inode);		         // Free the inode's memory
       cur->pg_dir = cur_pagedir_bak;
    }
    set_intr_status(old_status);
 }

 
 /* Initialize a new inode */
 void inode_init(uint32_t inode_no, Inode* new_inode) {
    new_inode->i_no = inode_no;
    new_inode->i_size = 0;
    new_inode->i_open_cnts = 0;
    new_inode->write_deny = false;
 
    /* Initialize the block index array i_sectors */
    uint8_t sec_idx = 0;
    while (sec_idx < 13) {
       /* i_sectors[12] is the address of the first level indirect block */
       new_inode->i_sectors[sec_idx] = 0;
       sec_idx++;
    }
 }
 

```

`inode_open` 函数用于打开一个指定 inode 编号的 inode。首先，它在分区的打开 inode 列表中查找该 inode。如果在列表中找到了 inode，则增加其打开计数并返回该 inode。如果在列表中未找到该 inode，则通过调用 `inode_locate` 获取该 inode 的位置，然后从磁盘读取该 inode 数据。读取过程中，如果 inode 跨越了两个扇区，则分配一个 1024 字节的缓冲区，否则只需分配 512 字节。读取完 inode 后，将其复制到内存中，并将其添加到分区的打开 inode 列表中。最后，返回找到的 inode。

`inode_close` 函数用于关闭一个 inode。它首先减少 inode 的打开计数，如果打开计数为 0，则从打开 inode 列表中移除该 inode，并释放分配的内存。释放内存时，需要确保在内核空间中执行内存分配和释放操作。

`inode_init` 函数用于初始化一个新的 inode。它将 inode 的编号设置为指定的值，将 inode 大小和打开计数初始化为 0，并将写入限制标志设置为 `false`。此外，它初始化了 inode 的区块索引数组 `i_sectors`，并将每个索引值设置为 0。

## 文件相关的函数

```c
#define DEFAULT_SECS 1

/* File table */
File file_table[MAX_FILE_OPEN];

/* Retrieves an available slot in the global file table (file_table).
 * Returns the index of the slot if successful, or -1 if all slots are in use.
 */
int32_t get_free_slot_in_global(void)
{
    uint32_t fd_idx = 3; // Start from index 3, skipping stdin, stdout, stderr.
    while (fd_idx < MAX_FILE_OPEN)
    {
        if (file_table[fd_idx].fd_inode ==
            NULL)
        { // Check if the inode is NULL.
            break;
        }
        fd_idx++;
    }
    if (fd_idx == MAX_FILE_OPEN)
    { // All slots are in use.
        ccos_printk("exceed max open files\n");
        return -1;
    }
    return fd_idx;
}

/* Installs the global file descriptor index into the process or thread's local
 * file descriptor table (fd_table). Returns the local file descriptor index if
 * successful, or -1 if all local file descriptor slots are in use. */
int32_t pcb_fd_install(int32_t global_fd_idx)
{
    TaskStruct *cur = current_thread(); // Get the current running thread.
    uint8_t local_fd_idx =
        3; // Start from index 3, skipping stdin, stdout, stderr.
    while (local_fd_idx < MAX_FILES_OPEN_PER_PROC)
    {
        if (cur->fd_table[local_fd_idx] == -1)
        { // -1 means the slot is free.
            cur->fd_table[local_fd_idx] =
                global_fd_idx; // Install the global fd index.
            break;
        }
        local_fd_idx++;
    }
    if (local_fd_idx == MAX_FILES_OPEN_PER_PROC)
    { // All slots are in use.
        ccos_printk("exceed max open files_per_proc\n");
        return -1;
    }
    return local_fd_idx;
}

/* Allocates an inode and returns its inode number. */
int32_t inode_bitmap_alloc(DiskPartition *part)
{
    int32_t bit_idx =
        bitmap_scan(&part->inode_bitmap, 1); // Find an available bit.
    if (bit_idx == -1)
    {
        return -1;
    }
    bitmap_set(&part->inode_bitmap, bit_idx, 1); // Set the bit as used.
    return bit_idx;
}

/* Allocates a block and returns its block address. */
int32_t block_bitmap_alloc(DiskPartition *part)
{
    int32_t bit_idx =
        bitmap_scan(&part->block_bitmap, 1); // Find an available bit.
    if (bit_idx == -1)
    {
        return -1;
    }
    bitmap_set(&part->block_bitmap, bit_idx, 1); // Set the bit as used.
    /* Unlike inode_bitmap_alloc, this function returns the actual block
     * address, not the bitmap index. */
    return (part->sb->data_start_lba + bit_idx); // Calculate the block address.
}

/* Synchronizes the bitmap data of the given type (inode_bitmap or block_bitmap)
 * to the disk. The synchronization is performed by writing the relevant section
 * of the bitmap to the disk. */
void bitmap_sync(DiskPartition *part, uint32_t bit_idx, uint8_t btmp_type)
{
    uint32_t off_sec = bit_idx / 4096; // Offset of the sector in the bitmap.
    uint32_t off_size =
        off_sec * BLOCK_SIZE; // Offset in bytes within the bitmap.
    uint32_t sec_lba;         // Sector address to be written.
    uint8_t *
        bitmap_off; // Pointer to the specific part of the bitmap to be written.

    /* Synchronize inode_bitmap or block_bitmap based on the btmp_type argument.
     */
    switch (btmp_type)
    {
    case INODE_BITMAP:
        sec_lba = part->sb->inode_bitmap_lba + off_sec;
        bitmap_off = part->inode_bitmap.bits + off_size;
        break;

    case BLOCK_BITMAP:
        sec_lba = part->sb->block_bitmap_lba + off_sec;
        bitmap_off = part->block_bitmap.bits + off_size;
        break;
    }
    ide_write(part->my_disk, sec_lba, bitmap_off,
              1); // Write the bitmap data to disk.
}
```

`get_free_slot_in_global` 函数用于在全局文件表中找到一个空闲的插槽。它从索引 3 开始检查（跳过标准输入、标准输出和标准错误文件描述符），并查找一个未被占用的插槽。如果找到一个空闲的插槽，则返回其索引；如果没有空闲的插槽，则返回 -1，并打印错误信息。

`pcb_fd_install` 函数将全局文件描述符索引安装到进程或线程的本地文件描述符表中。它从索引 3 开始检查（同样跳过标准输入、标准输出和标准错误文件描述符），并寻找一个空闲的插槽。如果找到空闲的插槽，则将全局文件描述符索引安装到本地文件描述符表中，并返回本地文件描述符的索引。如果没有空闲插槽，则返回 -1，并打印错误信息。

`inode_bitmap_alloc` 函数为指定的磁盘分区分配一个 inode，并返回其 inode 编号。它通过扫描 inode 位图查找一个空闲的 inode，如果没有空闲的 inode，则返回 -1。如果找到空闲 inode，则将其对应的位设置为已使用，并返回 inode 编号。

`block_bitmap_alloc` 函数为指定的磁盘分区分配一个数据块，并返回该块的地址。它通过扫描块位图查找一个空闲的块，如果没有空闲的块，则返回 -1。如果找到空闲块，则将其对应的位设置为已使用，并返回块的实际地址（通过数据起始 LBA 和位图索引计算）。

`bitmap_sync` 函数用于同步指定类型的位图（inode 位图或块位图）到磁盘。它根据传入的 `btmp_type`（位图类型）参数，确定是同步 inode 位图还是块位图。通过计算位图的扇区偏移量，它将位图的相应部分写入磁盘，确保位图的数据保持一致。

## 目录相关的函数

```c
// Root directory structure
Dir root_dir;

/**
 * Opens the root directory on the specified disk partition.
 * @param part The disk partition containing the root directory.
 */
void open_root_dir(DiskPartition *part) {
    root_dir.inode = inode_open(part, part->sb->root_inode_no);
    root_dir.dir_pos = 0;
}

/**
 * Opens a directory by its inode number on the specified partition.
 * @param part The disk partition.
 * @param inode_no The inode number of the directory.
 * @return A pointer to the opened directory structure.
 */
Dir *dir_open(DiskPartition *part, uint32_t inode_no) {
    Dir *pdir = (Dir *)sys_malloc(sizeof(Dir));
    pdir->inode = inode_open(part, inode_no);
    pdir->dir_pos = 0;
    return pdir;
}

/**
 * Searches for a directory entry with the specified name in the given
 * directory.
 * @param part The disk partition.
 * @param pdir The directory to search.
 * @param name The name of the target file or directory.
 * @param dir_e A pointer to store the found directory entry.
 * @return True if the directory entry is found, false otherwise.
 */
bool search_dir_entry(DiskPartition *part, Dir *pdir, const char *name,
                      DirEntry *dir_e) {
    uint32_t block_cnt =
        140; // Total of 12 direct blocks and 128 indirect blocks
    uint32_t *all_blocks = (uint32_t *)sys_malloc(48 + 512);
    if (!all_blocks ) {
        ccos_printk("search_dir_entry: sys_malloc for all_blocks failed");
        return false;
    }

    uint32_t block_idx = 0;
    while (block_idx < 12) {
        all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
        block_idx++;
    }

    if (pdir->inode->i_sectors[12] != 0) {
        ide_read(part->my_disk, pdir->inode->i_sectors[12], all_blocks + 12, 1);
    }

    uint8_t *buf = (uint8_t *)sys_malloc(SECTOR_SIZE);
    DirEntry *p_de = (DirEntry *)buf;
    uint32_t dir_entry_size = part->sb->dir_entry_size;
    uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;

    while (block_idx < block_cnt) {
        if (all_blocks[block_idx] == 0) {
            block_idx++;
            continue;
        }

        ide_read(part->my_disk, all_blocks[block_idx], buf, 1);
        uint32_t dir_entry_idx = 0;

        while (dir_entry_idx < dir_entry_cnt) {
            if (!k_strcmp(p_de->filename, name)) {
                k_memcpy(dir_e, p_de, dir_entry_size);
                sys_free(buf);
                sys_free(all_blocks);
                return true;
            }
            dir_entry_idx++;
            p_de++;
        }
        block_idx++;
        p_de = (DirEntry *)buf;
        k_memset(buf, 0, SECTOR_SIZE);
    }
    sys_free(buf);
    sys_free(all_blocks);
    return false;
}

/**
 * Closes a directory. Note that the root directory should never be closed.
 * @param dir The directory to close.
 */
void dir_close(Dir *dir) {
    if (dir == &root_dir) {
        return;
    }
    inode_close(dir->inode);
    sys_free(dir);
}

/**
 * Initializes a directory entry in memory.
 * @param filename The name of the file or directory.
 * @param inode_no The inode number.
 * @param file_type The type of the file (directory or regular file).
 * @param p_de A pointer to the directory entry to be initialized.
 */
void create_dir_entry(char *filename, uint32_t inode_no, uint8_t file_type,
                      DirEntry *p_de) {
    KERNEL_ASSERT(k_strlen(filename) <= MAX_FILE_NAME_LEN);
    k_memcpy(p_de->filename, filename, k_strlen(filename));
    p_de->i_no = inode_no;
    p_de->f_type = file_type;
}
```

`open_root_dir` 函数用于打开指定磁盘分区上的根目录。它通过根目录的 inode 号打开 inode，并将目录位置指针初始化为 0。

`dir_open` 函数通过给定的 inode 号打开指定磁盘分区上的目录。它分配一个 `Dir` 结构体，调用 `inode_open` 打开相应的 inode，并将目录位置指针初始化为 0，最后返回打开的目录结构。

`search_dir_entry` 函数用于在给定的目录中查找指定名称的目录项。它首先准备一个足够大的内存空间以存储所有块的地址（包括直接块和间接块），然后读取这些块的数据。如果目录项的名称与目标名称匹配，则将该目录项存储到 `dir_e` 中并返回 `true`，否则继续搜索。如果搜索结束仍未找到，返回 `false`。

`dir_close` 函数用于关闭一个目录。如果目录是根目录，则不执行任何操作。否则，关闭该目录的 inode 并释放目录结构的内存。

`create_dir_entry` 函数用于初始化一个目录项，设置文件名、inode 号和文件类型（目录或常规文件）。它检查文件名的长度，确保它不会超过最大文件名长度，并将文件名、inode 号和文件类型复制到目录项中。

```c
/**
 * Synchronizes a directory entry by writing it to disk.
 * @param parent_dir The parent directory.
 * @param p_de The directory entry to write.
 * @param io_buf A buffer used for I/O operations.
 * @return True if the operation succeeds, false otherwise.
 */
bool sync_dir_entry(Dir *parent_dir, DirEntry *p_de, void *io_buf) {
    Inode *dir_inode = parent_dir->inode;
    uint32_t dir_size[[maybe_unused]] = dir_inode->i_size;
    uint32_t dir_entry_size = cur_part->sb->dir_entry_size;

    KERNEL_ASSERT(dir_size % dir_entry_size == 0);

    uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
    int32_t block_lba = -1;
    uint8_t block_idx = 0;
    uint32_t all_blocks[140] = {0};

    while (block_idx < 12) {
        all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
        block_idx++;
    }

    DirEntry *dir_e = (DirEntry *)io_buf;
    int32_t block_bitmap_idx = -1;
    block_idx = 0;

    while (block_idx < 140) {
        block_bitmap_idx = -1;
        if (all_blocks[block_idx] == 0) {
            block_lba = block_bitmap_alloc(cur_part);
            if (block_lba == -1) {
                ccos_printk("alloc block bitmap for sync_dir_entry failed\n");
                return false;
            }
            block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
            KERNEL_ASSERT(block_bitmap_idx != -1);
            bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

            if (block_idx < 12) {
                dir_inode->i_sectors[block_idx] = all_blocks[block_idx] =
                    block_lba;
            } else if (block_idx == 12) {
                dir_inode->i_sectors[12] = block_lba;
                block_lba = block_bitmap_alloc(cur_part);
                if (block_lba == -1) {
                    block_bitmap_idx =
                        dir_inode->i_sectors[12] - cur_part->sb->data_start_lba;
                    bitmap_set(&cur_part->block_bitmap, block_bitmap_idx, 0);
                    dir_inode->i_sectors[12] = 0;
                    ccos_printk("alloc block bitmap for sync_dir_entry failed\n");
                    return false;
                }

                block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
                KERNEL_ASSERT(block_bitmap_idx != -1);
                bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
                all_blocks[12] = block_lba;
                ide_write(cur_part->my_disk, dir_inode->i_sectors[12],
                          all_blocks + 12, 1);
            } else {
                all_blocks[block_idx] = block_lba;
                ide_write(cur_part->my_disk, dir_inode->i_sectors[12],
                          all_blocks + 12, 1);
            }

            k_memset(io_buf, 0, 512);
            k_memcpy(io_buf, p_de, dir_entry_size);
            ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
            dir_inode->i_size += dir_entry_size;
            return true;
        }

        ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
        uint8_t dir_entry_idx = 0;

        while (dir_entry_idx < dir_entrys_per_sec) {
            if ((dir_e + dir_entry_idx)->f_type == FT_UNKNOWN) {
                k_memcpy(dir_e + dir_entry_idx, p_de, dir_entry_size);
                ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
                dir_inode->i_size += dir_entry_size;
                return true;
            }
            dir_entry_idx++;
        }
        block_idx++;
    }
    ccos_printk("directory is full!\n");
    return false;
}
```

`sync_dir_entry`函数的作用是将目录项同步到磁盘。首先，它从父目录的inode中获取目录的大小，并从当前分区的超级块中获取目录项的大小。通过确保目录大小是目录项大小的整数倍来进行检查。接下来，计算每个扇区能够存储多少个目录项。如果目录的某个块为空（即块地址为0），则会为该块分配一个新的块。如果是第13个块（即使用了间接块），会分配一个新的块用于间接地址，并更新相应的条目。然后，函数开始检查每个块，寻找空闲位置来写入新的目录项。空闲位置是通过检查目录项类型是否为`FT_UNKNOWN`来判断的。如果找到了空闲位置，目录项会被写入该位置，并且inode的大小会增加。数据会通过`ide_write`函数写入磁盘。如果遍历完所有块后依然没有找到空闲位置，函数会打印出“目录已满”的错误信息并返回`false`。如果操作成功，返回`true`。这个过程确保目录项的写入操作能够在磁盘上同步，并且能够管理目录的块分配。

## 路径解析

```c
/* Parse the top-level path name */
char *path_parse(char *pathname, char *name_store)
{
    if (pathname[0] == '/')
    { // No need to parse the root directory separately
        /* Skip consecutive '/' characters in the path, e.g., "///a/b" */
        while (*(++pathname) == '/')
            ;
    }

    /* Start general path parsing */
    while (*pathname != '/' && *pathname != 0)
    {
        *name_store++ = *pathname++;
    }

    if (pathname[0] == 0)
    { // If the path string is empty, return NULL
        return NULL;
    }
    return pathname;
}

/* Return the depth of the path, e.g., for /a/b/c, the depth is 3 */
int32_t path_depth_cnt(char *pathname)
{
    KERNEL_ASSERT(pathname);
    char *p = pathname;
    char name[MAX_FILE_NAME_LEN]; // Used as the parameter for path_parse to
                                  // parse the path
    uint32_t depth = 0;

    /* Parse the path and split it into individual names */
    p = path_parse(p, name);
    while (name[0])
    {
        depth++;
        k_memset(name, 0, MAX_FILE_NAME_LEN);
        if (p)
        { // If p is not NULL, continue analyzing the path
            p = path_parse(p, name);
        }
    }
    return depth;
}
```

`path_parse`函数用于解析路径名。它首先检查路径名是否以斜杠`/`开始，如果是，则跳过连续的斜杠。在解析路径时，它逐个字符将路径名的组件存储到`name_store`中，直到遇到下一个斜杠或路径结束。如果路径名结束，它返回`NULL`。否则，返回下一个待解析的路径部分。

`path_depth_cnt`函数用于计算路径的深度。例如，给定路径`/a/b/c`，深度为3。它通过调用`path_parse`函数不断解析路径并计算路径中目录或文件的数量，直到路径解析完毕。

## 实现文件检索

​	这里需要补充一下：

```c
#ifndef __FS_FS_H
#define __FS_FS_H
#include "include/library/types.h"
#include "include/device/ide.h"
#include "include/filesystem/filesystem_settings.h"

typedef struct __dir Dir;
typedef struct __dirEntry DirEntry;

/* File types */
enum file_types {
   FT_UNKNOWN,    // Unsupported file type
   FT_REGULAR,    // Regular file
   FT_DIRECTORY   // Directory
};

/* File open options */
enum oflags {
   O_RDONLY,      // Read-only
   O_WRONLY,      // Write-only
   O_RDWR,        // Read and write
   O_CREAT = 4    // Create
};

/* File seek position offset */
enum whence {
   SEEK_SET = 1,  // Seek from the beginning of the file
   SEEK_CUR,      // Seek from the current position
   SEEK_END       // Seek from the end of the file
};

/* Structure to record the search path during file lookup */
struct path_search_record {
   char searched_path[MAX_PATH_LEN]; // Parent path during file lookup
   Dir* parent_dir;                  // Direct parent directory of the file or directory
   enum file_types file_type;        // File type found (regular file, directory, or unknown if not found)
};

/* File attributes structure */
struct stat {
   uint32_t st_ino;        // Inode number
   uint32_t st_size;       // File size
   enum file_types st_filetype; // File type
};
#endif
```

​	我们的函数在下面

```c
/* Search for the file by pathname, return its inode number if found, otherwise
 * return -1 */
static int search_file(const char *pathname,
                       struct path_search_record *searched_record)
{
    /* If the root directory is being searched, return the known root directory
     * information */
    if (!k_strcmp(pathname, "/") || !k_strcmp(pathname, "/.") ||
        !k_strcmp(pathname, "/.."))
    {
        searched_record->parent_dir = &root_dir;
        searched_record->file_type = FT_DIRECTORY;
        searched_record->searched_path[0] = 0; // Clear the search path
        return 0;
    }

    uint32_t path_len[[maybe_unused]] = k_strlen(pathname);
    /* Ensure pathname is in the format /x and has a valid length */
    KERNEL_ASSERT(pathname[0] == '/' && path_len > 1 && path_len < MAX_PATH_LEN);
    char *sub_path = (char *)pathname;
    Dir *parent_dir = &root_dir;
    DirEntry dir_e;

    /* Record the parsed path names, e.g., for "/a/b/c", the array name will
     * hold "a", "b", "c" */
    char name[MAX_FILE_NAME_LEN] = {0};

    searched_record->parent_dir = parent_dir;
    searched_record->file_type = FT_UNKNOWN;
    uint32_t parent_inode_no = 0; // Parent directory's inode number

    sub_path = path_parse(sub_path, name);
    while (name[0])
    {   // If the first character is the end of the string, stop
        // the loop
        /* Record the paths searched, but ensure the searched path does not
         * exceed 512 bytes */
        KERNEL_ASSERT(k_strlen(searched_record->searched_path) < 512);

        /* Record the existing parent directory */
        k_strcat(searched_record->searched_path, "/");
        k_strcat(searched_record->searched_path, name);

        /* Search for the file in the specified directory */
        if (search_dir_entry(cur_part, parent_dir, name, &dir_e))
        {
            k_memset(name, 0, MAX_FILE_NAME_LEN);
            /* If sub_path is not NULL, continue splitting the path */
            if (sub_path)
            {
                sub_path = path_parse(sub_path, name);
            }

            if (FT_DIRECTORY == dir_e.f_type)
            { // If the item is a directory
                parent_inode_no = parent_dir->inode->i_no;
                dir_close(parent_dir);
                parent_dir =
                    dir_open(cur_part, dir_e.i_no); // Update parent directory
                searched_record->parent_dir = parent_dir;
                continue;
            }
            else if (FT_REGULAR ==
                     dir_e.f_type)
            { // If the item is a regular file
                searched_record->file_type = FT_REGULAR;
                return dir_e.i_no;
            }
        }
        else
        { // If not found, return -1
            /* If the directory entry is not found, leave parent_dir open,
             * since creating a new file may require adding it to parent_dir */
            return -1;
        }
    }

    /* If we've reached this point, the path has been fully traversed and only a
     * directory with the same name exists */
    dir_close(searched_record->parent_dir);

    /* Save the direct parent directory of the found directory */
    searched_record->parent_dir = dir_open(cur_part, parent_inode_no);
    searched_record->file_type = FT_DIRECTORY;
    return dir_e.i_no;
}
```

`search_file`函数用于根据路径名查找文件。如果路径名是根目录`/`，则返回根目录的信息。否则，它会逐步解析路径中的每个部分，并在每个目录中查找对应的文件。如果找到了目录，它会更新父目录并继续查找子路径。如果找到的是文件，则返回该文件的inode号。如果路径部分没有找到对应的目录或文件，函数返回`-1`，表示未找到该路径。最终，它返回找到的文件的inode号或目录的inode号。

## 创建文件

```c
/* Creates a new file in the given parent directory.
 * Returns the file descriptor if successful, or -1 if an error occurs during
 * creation. */
int32_t file_create(Dir *parent_dir, char *filename, uint8_t flag)
{
    void *io_buf = sys_malloc(1024); // Allocate memory for a temporary buffer.
    if (!io_buf)
    {
        ccos_printk("in file_create: sys_malloc for io_buf failed\n");
        return -1;
    }

    uint8_t rollback_step =
        0; // Step counter for rolling back resources in case of failure.

    /* Allocate an inode for the new file. */
    int32_t inode_no = inode_bitmap_alloc(cur_part);
    if (inode_no == -1)
    {
        ccos_printk("in file_create: allocate inode failed\n");
        return -1;
    }

    /* Allocate memory for the inode and initialize it. */
    Inode *new_file_inode =
        (Inode *)sys_malloc(sizeof(Inode));
    if (!new_file_inode)
    {
        ccos_printk("file_create: sys_malloc for inode failed\n");
        rollback_step = 1;
        goto rollback;
    }
    inode_init(inode_no, new_file_inode); // Initialize the inode.

    /* Get an available slot in the global file table. */
    int fd_idx = get_free_slot_in_global();
    if (fd_idx == -1)
    {
        ccos_printk("exceed max open files\n");
        rollback_step = 2;
        goto rollback;
    }

    /* Initialize the file table entry for the new file. */
    file_table[fd_idx].fd_inode = new_file_inode;
    file_table[fd_idx].fd_pos = 0;
    file_table[fd_idx].fd_flag = flag;
    file_table[fd_idx].fd_inode->write_deny = false;

    /* Create a directory entry for the new file. */
    DirEntry new_dir_entry;
    k_memset(&new_dir_entry, 0, sizeof(DirEntry));
    create_dir_entry(filename, inode_no, FT_REGULAR,
                     &new_dir_entry); // Create the directory entry.

    /* Synchronize the directory entry to the disk. */
    if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf))
    {
        ccos_printk("sync dir_entry to disk failed\n");
        rollback_step = 3;
        goto rollback;
    }

    k_memset(io_buf, 0, 1024);
    /* Synchronize the parent directory's inode to the disk. */
    inode_sync(cur_part, parent_dir->inode, io_buf);

    k_memset(io_buf, 0, 1024);
    /* Synchronize the new file's inode to the disk. */
    inode_sync(cur_part, new_file_inode, io_buf);

    /* Synchronize the inode bitmap to the disk. */
    bitmap_sync(cur_part, inode_no, INODE_BITMAP);

    /* Add the newly created file's inode to the open_inodes list. */
    list_push(&cur_part->open_inodes, &new_file_inode->inode_tag);
    new_file_inode->i_open_cnts = 1;

    sys_free(io_buf);
    return pcb_fd_install(
        fd_idx); // Install the file descriptor in the process's fd_table.

rollback:
    /* If any step fails, roll back the allocated resources. */
    switch (rollback_step)
    {
    case 3:
        /* Clear the file table entry if synchronization fails. */
        k_memset(&file_table[fd_idx], 0, sizeof(File));
        goto FREE_SRC;
        break;
    case 2:
    FREE_SRC:
        sys_free(new_file_inode); // Free the inode memory.
        goto RESET_MAP;
        break;
    case 1:
    RESET_MAP:
        /* Roll back the inode allocation if it failed. */
        bitmap_set(&cur_part->inode_bitmap, inode_no, 0);
        break;
    }
    sys_free(io_buf);
    return -1;
}
```

`file_create`函数用于在给定的父目录中创建新文件。首先，它为临时缓冲区分配内存，如果分配失败则返回`-1`。接着，函数按顺序进行以下步骤：

1. 分配一个inode，并初始化它。如果inode分配失败，函数返回`-1`。
2. 获取一个全局文件表中的空闲槽位，若获取失败，则回滚已分配的资源并返回`-1`。
3. 初始化新文件的文件表条目，包括文件的inode、偏移量和标志等信息。
4. 创建目录项（`DirEntry`）并将其同步到磁盘。如果同步失败，则回滚已分配的资源并返回`-1`。
5. 将父目录和新文件的inode同步到磁盘。
6. 更新inode位图以反映新的inode分配。
7. 将新文件的inode添加到当前分区的`open_inodes`链表中，表示该inode已被打开。
8. 返回新文件的文件描述符。

如果在执行过程中遇到任何错误，函数会回滚已分配的资源，以确保系统状态一致。例如，它会清除文件表条目，释放内存或取消inode分配，确保不留下任何资源泄漏。最终，如果一切成功，返回安装的文件描述符。

回滚步骤是根据出错的地方逐步清理已分配资源。

## 实现一下sys_open

```c
/* Open or create a file, return the file descriptor if successful, otherwise
 * return -1 */
int32_t sys_open(const char *pathname, uint8_t flags) {
    /* Directories should be opened with dir_open, here we only open files */
    if (pathname[k_strlen(pathname) - 1] == '/') {
        ccos_printk("can't open a directory %s\n", pathname);
        return -1;
    }
    KERNEL_ASSERT(flags <= 7);
    int32_t fd = -1; // Default value indicating file not found

    struct path_search_record searched_record;
    k_memset(&searched_record, 0, sizeof(struct path_search_record));

    /* Record the directory depth to help determine if a subdirectory doesn't
     * exist */
    uint32_t pathname_depth = path_depth_cnt((char *)pathname);

    /* First, check if the file exists */
    int inode_no = search_file(pathname, &searched_record);
    bool found = inode_no != -1 ? true : false;

    if (searched_record.file_type == FT_DIRECTORY) {
        ccos_printk("can't open a directory with open(), use opendir() instead\n");
        dir_close(searched_record.parent_dir);
        return -1;
    }

    uint32_t path_searched_depth =
        path_depth_cnt(searched_record.searched_path);

    /* Check if the entire pathname was accessed, meaning no directory in the
     * path was missing */
    if (pathname_depth != path_searched_depth) { // This means some intermediate
                                                 // directory is missing
        ccos_printk("sorry! cannot access %s: Not a directory, subpath %s isn't exist\n",
               pathname, searched_record.searched_path);
        dir_close(searched_record.parent_dir);
        return -1;
    }

    /* If the file wasn't found and we don't want to create it, return -1 */
    if (!found && !(flags & O_CREAT)) {
        ccos_printk("however in path %s, file %s isn't exist\n",
               searched_record.searched_path,
               (k_strrchr(searched_record.searched_path, '/') + 1));
        dir_close(searched_record.parent_dir);
        return -1;
    } else if (found && flags & O_CREAT) { // If the file already exists but we
                                           // want to create it
        ccos_printk("but %s has already exist!\n", pathname);
        dir_close(searched_record.parent_dir);
        return -1;
    }

    switch (flags & O_CREAT) {
    case O_CREAT:
        ccos_printk("creating file!\n");
        fd = file_create(searched_record.parent_dir,
                         (k_strrchr(pathname, '/') + 1), flags);
        dir_close(searched_record.parent_dir);
        break;
    default:
        /* For other cases, open an existing file: O_RDONLY, O_WRONLY, O_RDWR */
        fd = file_open(inode_no, flags);
    }

    /* The returned fd is the index of the element in the task's fd_table array,
     * not the global file_table index */
    return fd;
}
```

`sys_open`函数用于打开或创建文件。首先，函数会检查传入的路径名是否以`/`结尾，如果是，则返回错误，因为`sys_open`不能打开目录。接着，它初始化一个路径搜索记录结构，并计算路径的深度，以确定是否存在缺失的子目录。然后，调用`search_file`函数检查文件是否存在。如果文件是目录类型，则输出错误信息并返回`-1`。接下来，函数会检查路径是否完全访问，如果路径深度不一致，表示路径中有子目录不存在，则返回错误。接着，如果文件不存在且没有`O_CREAT`标志，函数返回`-1`；如果文件存在且有`O_CREAT`标志，返回错误信息。如果文件不存在且有`O_CREAT`标志，`sys_open`会调用`file_create`来创建新文件。如果文件已经存在，则直接打开文件。最后，返回文件描述符。

​	我们还需要打开根目录并初始化文件表

```
// filesystem_init函数下追加：
    /* Open the root directory of the current partition */
    open_root_dir(cur_part);

    /* Initialize the file table */
    uint32_t fd_idx = 0;
    while (fd_idx < MAX_FILE_OPEN) {
        file_table[fd_idx++].fd_inode = NULL;
    }
```

## 测试一下：

```c
#include "include/device/console_tty.h"
#include "include/kernel/init.h"
#include "include/library/kernel_assert.h"
#include "include/thread/thread.h"
#include "include/user/stdio/stdio.h"
#include "include/memory/memory.h"
#include "include/library/ccos_print.h"
#include "include/filesystem/filesystem.h"

int main(void) { 
    init_all(); 
    sys_open("/file1", O_CREAT); 
    while(1); 
    return 0; 
} 
```

![image-20250309222440092](./13.3_impl_fd/image-20250309222440092.png)

![image-20250309223549471](./13.3_impl_fd/image-20250309223549471.png)

## 关闭文件

```c
/* Convert the file descriptor to the global file table index */
uint32_t fd_local2global(uint32_t local_fd) {
    TaskStruct *cur = current_thread();
    int32_t global_fd = cur->fd_table[local_fd];
    KERNEL_ASSERT(global_fd >= 0 && global_fd < MAX_FILE_OPEN);
    return (uint32_t)global_fd;
}

/* Close the file associated with fd, return 0 on success, otherwise return -1
 */
int32_t sys_close(int32_t fd) {
    int32_t ret = -1; // Default return value indicating failure
    if (fd > 2) {
        uint32_t _fd = fd_local2global(fd); 
        ret = file_close(&file_table[_fd]);
        current_thread()->fd_table[fd] = -1; 
    }
    return ret;
}
```

`fd_local2global`函数将本地文件描述符转换为全局文件表索引。首先，它获取当前任务的文件描述符表，然后根据传入的本地文件描述符返回对应的全局文件描述符索引。

`sys_close`函数用于关闭文件。首先，它检查文件描述符是否大于2（标准输入、输出和错误文件描述符不处理）。然后，调用`fd_local2global`将本地文件描述符转换为全局文件描述符，并尝试关闭文件。如果成功，更新任务的文件描述符表并返回0；否则，返回`-1`。
