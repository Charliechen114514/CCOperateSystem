# 实现PWD

在 Linux 操作中，当我们使用 `cd` 命令进入子目录时，系统会更改当前的工作目录。而如果没有配置显示完整路径的 shell（通过修改 `$PS1` 变量），我们可以使用 `pwd` 命令来显示当前工作路径。

要理解 `pwd` 命令是如何实现的，我们需要考虑每个目录中都有一个特殊的目录项“..”，它表示父目录。因此，不论我们处于哪一级子目录，只要有了“..”，我们就可以沿着父目录一步一步向上找到根目录。

具体实现过程是，系统首先通过“..”来获取当前目录的父目录，然后在父目录中找到当前目录的目录项，通过目录项得到当前目录的名称。接着，系统继续向上查找父目录的父目录，并依此类推，最终构建出从根目录到当前目录的绝对路径。这就是 `pwd` 命令获取当前工作目录的基本原理。

```c
/* Gets the inode number of the parent directory of a given directory */
static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void *io_buf)
{
    Inode *child_dir_inode = inode_open(cur_part, child_inode_nr);
    /* The directory entry for ".." includes the parent directory inode number,
       ".." is located in the first block of the directory */
    uint32_t block_lba = child_dir_inode->i_sectors[0];
    KERNEL_ASSERT(block_lba >= cur_part->sb->data_start_lba);
    inode_close(child_dir_inode);
    ide_read(cur_part->my_disk, block_lba, io_buf, 1);
    DirEntry *dir_e = (DirEntry *)io_buf;
    /* The first directory entry is ".", the second directory entry is ".." */
    KERNEL_ASSERT(dir_e[1].i_no < 4096 && dir_e[1].f_type == FT_DIRECTORY);
    return dir_e[1]
        .i_no; // Return the inode number of "..", which is the parent directory
}
```

​	实现了 `get_parent_dir_inode_nr` 函数，目的是获取给定目录的父目录的 inode 号。首先，通过 `inode_open` 打开指定 `child_inode_nr` 对应的子目录的 inode。然后，它读取子目录的第一个数据块的块地址（`i_sectors[0]`）并确保该块地址有效。

接着，使用 `ide_read` 读取该数据块的内容到缓冲区 `io_buf` 中。由于该数据块包含目录项，而目录项中的第一个项是当前目录 (`"."`)，第二个项是父目录 (`".."`)，因此可以通过索引 1 获取父目录的 inode 号。返回父目录的 inode 号。

在代码中，`KERNEL_ASSERT` 用于确保目录项中第二项的 inode 号小于 4096，且其类型是目录类型（`FT_DIRECTORY`），这两项条件确认了该目录项表示父目录。

## sys_getcwd

​	我们需要修订一下TaskStruct

```c
/**
 * @brief Process Control Block (PCB) structure for threads and processes.
 *
 * This structure stores the execution context, scheduling information,
 * and resources associated with a thread or process.
 */
typedef struct
{
    uint32_t *self_kstack;         // Pointer to the kernel stack of the thread
    pid_t pid;                     // Process ID
    TaskStatus status;             // Current status of the thread
    char name[TASK_NAME_ARRAY_SZ]; // Name of the thread
    uint8_t priority;              // Thread priority level
    uint8_t ticks;                 // Time slices allocated per execution cycle
    uint32_t elapsed_ticks;        // Total CPU time consumed

    /**
     * @brief General list element for scheduling queues.
     *
     * Used to manage the thread in general scheduling queues.
     */
    list_elem general_tag;

    /**
     * @brief List element for all threads.
     *
     * Used to track all threads in the system.
     */
    list_elem all_list_tag;

    uint32_t *pg_dir;                   // Virtual address of process page directory
    VirtualMemoryHandle userprog_vaddr; // User process virtual memory space
    MemoryBlockDescriptor
        u_block_desc[DESC_CNT];                // User process memory block descriptors
    int32_t fd_table[MAX_FILES_OPEN_PER_PROC]; // File descriptors of opened files
    uint32_t cwd_inode_nr;                     // Inode number of the current working directory
    uint32_t stack_magic;                      // Stack boundary marker for overflow detection
} TaskStruct;
```

​	载初始化线程的时候给cwd_inode_nr一个0

```c
/* Initialize basic thread information */
void init_thread(TaskStruct *pthread, char *name, int prio) {
    k_memset(pthread, 0, sizeof(*pthread));
    pthread->pid = allocate_pid(); // Assign a new pid
    k_strcpy(pthread->name, name);

    if (pthread == main_thread) {
        /* Main thread is set to TASK_RUNNING since it's always running */
        pthread->status = TASK_RUNNING;
    } else {
        pthread->status = TASK_READY;
    }

    /* Initialize the thread's kernel stack */
    pthread->self_kstack = (uint32_t *)((uint32_t)pthread + PG_SIZE);
    pthread->priority = prio;
    pthread->ticks = prio; // Set the number of ticks based on priority
    pthread->elapsed_ticks = 0;
    pthread->pg_dir = NULL;

    init_fd_table(pthread);
    pthread->cwd_inode_nr = 0;       // root is default 
    pthread->stack_magic =
        TASK_MAGIC; // Custom magic number for stack validation
}
```

​	我们封装成系统调用：

```
/* Writes the absolute path of the current working directory into the buffer
   buf, size is the size of buf. If buf is NULL, the operating system allocates
   memory for the working path and returns the address. Returns NULL on failure
 */
char *sys_getcwd(char *buf, uint32_t size)
{
    /* Ensure buf is not NULL, if the user's buf is NULL,
       the system call getcwd allocates memory for the user's process via malloc
     */
    KERNEL_ASSERT(buf);
    void *io_buf = sys_malloc(SECTOR_SIZE);
    if (!io_buf)
    {
        return NULL;
    }
    TaskStruct *cur_thread = current_thread();
    int32_t parent_inode_nr = 0;
    int32_t child_inode_nr = cur_thread->cwd_inode_nr;
    KERNEL_ASSERT(child_inode_nr >= 0 &&
           child_inode_nr < 4096); // Maximum 4096 inodes supported
    /* If the current directory is the root directory, return '/' */
    if (child_inode_nr == 0)
    {
        buf[0] = '/';
        buf[1] = 0;
        sys_free(io_buf);
        return buf;
    }

    k_memset(buf, 0, size);
    char full_path_reverse[MAX_PATH_LEN] = {0}; // Buffer for the full path

    /* Traverse upwards through the parent directories until the root directory
     * is found. When child_inode_nr is the inode number of the root directory
     * (0), stop, meaning we have processed all directory entries in the root
     * directory */
    while ((child_inode_nr))
    {
        parent_inode_nr = get_parent_dir_inode_nr(child_inode_nr, io_buf);
        if (get_child_dir_name(
                parent_inode_nr, child_inode_nr, full_path_reverse,
                io_buf) == -1)
        { // If name not found, fail and exit
            sys_free(io_buf);
            return NULL;
        }
        child_inode_nr = parent_inode_nr;
    }
    KERNEL_ASSERT(k_strlen(full_path_reverse) <= size);
    /* Now full_path_reverse contains the path in reverse order,
     * i.e., child directory is at the front (left), parent directory at the
     * back (right), reverse the path */
    char *last_slash; // To store the address of the last slash in the string
    while ((last_slash = k_strrchr(full_path_reverse, '/')))
    {
        uint16_t len = k_strlen(buf);
        k_strcpy(buf + len, last_slash);
        /* Add the null terminator in full_path_reverse to act as the boundary
         * for the next strcpy */
        *last_slash = 0;
    }
    sys_free(io_buf);
    return buf;
}

```

首先，检查 `buf` 是否为空，如果为空，则操作系统会分配内存来存储路径。接着，使用 `sys_malloc` 分配一个缓冲区 `io_buf`，用于存储一些临时数据。如果内存分配失败，则返回 `NULL`。

获取当前线程（进程）的工作目录 inode 号 (`cur_thread->cwd_inode_nr`)。如果该 inode 号为根目录的 inode 号（`0`），则表示当前目录是根目录，直接返回 `"/"` 作为路径。

如果当前工作目录不是根目录，则通过一个循环向上遍历父目录，直到根目录为止。在这个过程中，通过 `get_parent_dir_inode_nr` 获取当前目录的父目录 inode 号，并通过 `get_child_dir_name` 获取当前目录的名称。

遍历过程中将路径以反向顺序存储在 `full_path_reverse` 缓冲区中。反向顺序是因为从子目录遍历到父目录，所以路径是反向构建的。

完成遍历后，`full_path_reverse` 中存储的是路径的反向顺序。使用 `k_strrchr` 和 `k_strcpy` 将路径逆序转换为正向顺序，最终得到完整的路径。

最后，释放 `io_buf` 分配的内存，并返回最终的路径缓冲区 `buf`。

## 测试

```c
int main(void)
{
    init_all();
    char cwd_buf[32] = {0}; 
    sys_getcwd(cwd_buf, 32); 
    printf("cwd:%s\n", cwd_buf); 
    sys_chdir("/dir1"); 
    printf("change cwd now\n"); 
    sys_getcwd(cwd_buf, 32); 
    printf("cwd:%s\n", cwd_buf);
    
    while (1)
        ;
    return 0;
}
```

![image-20250309234006693](./13.9_pwd/image-20250309234006693.png)
