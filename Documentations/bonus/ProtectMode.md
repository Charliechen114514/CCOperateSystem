# Protect Mode Introduction

​	保护模式出生在我们的实模式之后，或者说，在之前，针对Intel的CPU，是没有实模式这个概念的，保护模式出现后，作为对比，我们才将老的CPU模式称之为实模式。

​	所以，为什么会有保护模式呢？区别在哪里呢？

## 同实模式的区别

> 关于实模式，请参考笔者的文档：[Real Mode](./Real_Mode.md)

​	任何一个熟悉其他架构，特别是ARM架构的朋友都知道，程序的运行是存在特权级的。这里的特权级指代的是一些程序具备使用特权指令的特权，而另一些没有。

- 在实模式中，所有的程序，不论是操作系统，还是用户程序都是同样的特权级，没有分层。这个时候，如果用户程序有意或者是无意搞点事情——比如说这里踩点内存，那里写点数据，完全没有限制的话，系统非常容易崩溃，或者是发生莫名其妙的错误。
- 我们还知道，实模式下，没有启用页表和虚拟地址保护，所以，我们直接访问了物理地址，且不论可能导致潜在的物理碎片，我们直接杀到物理内存中去了，实在不太雅观，而且非常危险。
- 切换大于64KB的内存区域需要切换段基址，难以维护我们的程序
- 一次我们只能运行一个程序，MSDOS的事情大家都知道，不是吗。卡死了就是卡死了
- 最大就20根地址线，言外之意就是1MB，这30年前都不够用的（2025年算起）

## 现在是货真价实的IA32架构的CPU

​	虽然说x86_64时代的CPU，启动上已经做了很大的改进，比如说开机实际上就直接从32位开始启动等等，但是这不是我们这里的重点。

​	最经典的IA32架构的CPU，启动是从实模式进入保护模式的。也就是说，我们的IA32的CPU需要我们写系统程序，明显的指定我们的CPU从16位的实模式进入32位的保护模式。32位的CPU要保证像16位CPU的兼容（问就是Intel的兼容哲学）

## 现在是正文：起手讨论32位CPU的特征

### 寄存器

​	现在我们终于可以聊一聊32位CPU的特征了。首先，我们知道，32位这个词代表了非常多的含义。首先就是我们的CPU的操作数据线是32位了。意味着打配合的寄存器也就必须升级为32位。

| 31     | 15    | 7    | 0    | 位宽 |
| ------ | ----- | ---- | ---- | ---- |
| EAX    | AH    | AL   | AX   |      |
| EBX    | BH    | BL   | BX   |      |
| ECX    | CH    | CL   | CX   |      |
| EDX    | DH    | DL   | DX   |      |
| ESI    | SI    |      |      |      |
| EDI    | DI    |      |      |      |
| EBP    | BP    |      |      |      |
| ESP    | SP    |      |      |      |
| EFLAGS | FLAGS |      |      |      |
| EIP    | EIP   |      |      |      |
|        | CS    |      |      |      |
|        | DS    |      |      |      |
|        | ES    |      |      |      |
|        | FS    |      |      |      |
|        | GS    |      |      |      |
|        | SS    |      |      |      |

​	同时，我们需要注意，地址线作为数据线的一个特化，也被扩展为32位。也就是说，现在我们的内存**可以达到4GB大小**（当然，对于64位CPU而言这还是带有幽默意味的太小了，但是对我们demo级别的操作系统绰绰有余）

### 重构管理我们的内存段

​	之前在实模式中就讨论过的事情——我们的内存访问是分段的。现在是保护模式的时代，结合笔者说的内存访问的痛点，自然要对内存段做属性区分，告知对于当前的CPU状态下，哪些内存是可访问的，可写可读，是否可以被执行等等。所以，我们需要一块内存（当然不能塞寄存器里，地方显然不够），来薄记我们的内存段的属性和权限等等。这块内存，在x86架构中，就有了名字——

#### GDT表

​	GDT（Global Descriptor Table，全局描述符表）是x86架构中用于内存管理的重要数据结构。它定义了系统中各种内存段的属性和访问权限。GDT是保护模式下的核心组成部分，允许操作系统对内存进行更精细的控制和保护。表内，我们存放了各式各样的段描述符，用来说明一块内存的属性是如何的。

​	**我们要解决的痛点，是内存访问没有限制，所以，加上啥样的限制，就是我们的GDT表的设计的核心思路！**

- 实模式不知道这块内存是做什么的，所以，我们要添加一个内存属性的标志位，告知当前的CPU程序运行流这块内存是做啥的。是被读写的数据段，还是准备拿进去执行的可读可执行段？
- 实模式对程序的运行Level完全不自知，当然也就要添加特权级指标来进行区分
- 我们还需要描述

​	**一个段描述符大小是连续的64位，8个字节。**每一个位的含义就是这样的。

| 31~24        | 23   | 22   | 21   | 20   | 19~16        | 15   | 14~13 | 12   | 11~8 | 7~0          |
| ------------ | ---- | ---- | ---- | ---- | ------------ | ---- | ----- | ---- | ---- | ------------ |
| 段基址 31~24 | G    | D/B  | L    | AVL  | 段界限 19~16 | P    | DPL   | S    | TYPE | 段基址 23~16 |

| 31~16       | 15~0        |
| ----------- | ----------- |
| 段基址 15~0 | 段界限 15~0 |

​	我的天，还是一脸懵逼，不着急，听我慢慢说。

​	段基址大小是32位大小，就放在了段的描述符当中。所以你可以看到，这里有一半的空间，**被用来存储我们的段基址**。

​	段界限，我们需要回忆道，32位的CPU还没有抛弃经典的——段基址 + 偏移量的算法。所以，段界限就是告知我们的CPU，访问这个段的时候，最大的偏移地址不允许超过我们的界限。这里，需要注意的是，它的大小是灵活的！它可以是4KB，也自然可以是4GB。这是怎么来的呢？

​	答案是，根据我们的第55位：也就是G那一位决定的。G这个位表达的是内存薄记的粒度。当G为0的时候，我们的粒度是1字节。所以，就能得到我们的段界限极限就是**0xFFFFF**（是不是很熟悉？对咯！我们的GDT也可以用在16位CPU下了，这就是Intel对16位实模式的增强，但是这里我们用不到，不说了）。当G为1的时候，我们的粒度就是4KB。所以，20位就能表达到**0xFFFFFFFF**（0x100000 * 0x1000 - 1，减一的原因是我们的计数单位是从0开始的），所以，我们计算偏移地址的时候，首先拿到段界限内存贮的值，随后根据G标志位乘上粒度。最后换算出来的真实边界就跟我们打算访问的偏移地址做对比。当取到的偏移地址超过了我们的界限的时候，说明我们的内存访问非法了，需要速速报警。至于处理异常是我们之后要做的异常注册，很遥远，不着急。

​	下面我们说一说我们的type字段。一共4位。它实际上要跟我们的S段打配合。当S为1的时候，对于CPU而言他就是一个数据段，何为数据段？注意！这是对CPU说的，他不管这是代码还是数据还是什么，对他而言，他要处理的全部一股脑认为是数据！所以是数据段，当S为0的时候，这个段就是一个系统段。

​	系统段就是各种“门”结构，是硬件所需要的东西。他本质上存储的是硬件触发后的callback的地址。

#### 段描述符的type类型（系统段类型）

| 第3~0位  | 说明                |
| -------- | ------------------- |
| **0000** | 未定义              |
| **0001** | 可用的80286 TSS     |
| **0010** | 局部描述符表（LDT） |
| **0011** | 忙碌的80286 TSS     |
| **0100** | 80286调用门         |
| **0101** | 任务门              |
| **0110** | 80286中断门         |
| **0111** | 80286陷阱门         |
| **1000** | 未定义              |
| **1001** | 可用的80386 TSS     |
| **1010** | 未定义              |
| **1011** | 忙碌的80386 TSS     |
| **1100** | 80386调用门         |
| **1101** | 未定义              |
| **1110** | 中断门              |
| **1111** | 陷阱门              |

​	对于数据段，我们终于可以看到两个熟悉的面孔了！

#### 段描述符的type类型（数据段中的代码段含义`(X = 1)`）

| 内存段类型 | X    | R    | C    | A    | 说明                       |
| ---------- | ---- | ---- | ---- | ---- | -------------------------- |
| 代码段     | 1    | 0    | 0    | *    | 只执行代码段               |
|            | 1    | 1    | 0    | *    | 可执行、可读代码段         |
|            | 1    | 0    | 1    | *    | 可执行、一致性代码段       |
|            | 1    | 1    | 1    | *    | 可执行、可读、一致性代码段 |

#### 段描述符的type类型（数据段中的数据段含义`(X = 0)`）

| 内存段类型 | X    | W    | E    | A    | 说明                     |
| ---------- | ---- | ---- | ---- | ---- | ------------------------ |
| 数据段     | 0    | 0    | 0    | *    | 只读数据段               |
|            | 0    | 1    | 0    | *    | 可读写数据段             |
|            | 0    | 0    | 1    | *    | 只读，向下扩展的数据段   |
|            | 0    | 1    | 1    | *    | 可读写，向下扩展的数据段 |

​	A表达的就是Accessed，也就是是否被访问过，每当我们的CPU访问过过后，都会对A置上1，表达自己来过这里

​	C则是一致性代码段。这里的一致性，指代的是这个代码段有没有被共享，可以被低特权级的用户程序直接调用访问的代码段，这些代码段，通常是不去访问受保护的资源和某些类型异常处理。一致性的代码段要求：

- 特权级高的程序不允许访问特权级低的数据：即内核态不允许调用用户态的数据。
- 特权级低的程序可以访问到特权级高的程序，但是特权级不会改变，即不会从用户态切换到内核态。

​	与之针锋相对的就是非一致性代码段。这就是为了避免低特权级的访问而被操作系统保护起来的系统代码

- 只允许同特权级访问。
- 绝对禁止不同特权级直接访问：内核态不去用户态，用户态也不使用内核态。
- 通常低特权级代码必须通过门调用来实现对高特权级代码段的访问和调用。

​	R就是标识自己是否可读。

​	X标识自己是否可执行，基于此我们才会进一步区分代码段和数据段的。

​	E则是标识自己是堆段还是栈段，这是因为E为0的时候，表达的是自己的扩展向上，为1时向下，这不就是堆和栈的特征嘛！

​	W标识是否可以写入。（当然，在调试这种极端特殊的情况，会直接改段的属性写入int 3指令表达断点调试）

#### 其他位域

​	DPL表达了我们的特权级。要知道，X86有四个特权级。对于Linux，我们使用的是0特权级和3特权级。特权级越小，特权越大。

​	P表达了我们的段是否存在，当P不存在的时候（也就是0），访问这个段基址将会抛出CPU的异常。P是我们进行赋值，我们管理的。后面我们手动去写段描述符的性质的时候，还会谈到这一点。

​	AVL是给操作系统做保留的，干啥随它去，我们决定的

​	L则是表达这个是32位还是64位的代码段还是数据段，我们现在是32位的CPU跑32位的操作系统，自然就是直接给0就完事了

​	D/B段则是说明我们的指令中的有效地址和操作长度是多少，从而确保我们的32位和16位的代码段和数据段不要串位了。对于代码段，D=1表示32位段，D=0表示16位段。对于数据段，B=1表示32位段，B=0表示16位段。

#### 总结一下段描述符格式

| 位域      | 名称                             | 描述                                                         |
| :-------- | :------------------------------- | :----------------------------------------------------------- |
| **31~24** | 段基址 31~24                     | 段基地址的高8位，与23~16和15~0位共同构成32位的段基地址。     |
| **23**    | G (Granularity)                  | 粒度位。0表示段限长以字节为单位，1表示段限长以4KB为单位。    |
| **22**    | D/B (Default Operation Size/Big) | 对于代码段，D=1表示32位段，D=0表示16位段。对于数据段，B=1表示32位段，B=0表示16位段。 |
| **21**    | L (Long Mode)                    | 长模式位。1表示64位代码段，0表示32位代码段。                 |
| **20**    | AVL (Available)                  | 可供系统软件使用的位，通常由操作系统定义其用途。             |
| **19~16** | 段界限 19~16                     | 段限长的高4位，与15~0位共同构成20位的段限长。                |
| **15**    | P (Present)                      | 存在位。1表示段在内存中，0表示段不在内存中。                 |
| **14~13** | DPL (Descriptor Privilege Level) | 描述符特权级。0为最高特权级（内核模式），3为最低特权级（用户模式）。 |
| **12**    | S (Segment Type)                 | 段类型位。1表示代码段或数据段，0表示系统段（如任务状态段TSS）。 |
| **11~8**  | TYPE                             | 段类型字段，具体含义取决于S位： - 对于代码段：可执行、可读、访问位。 - 对于数据段：可写、扩展方向、访问位。 |
| **7~0**   | 段基址 23~16                     | 段基地址的中间8位，与31~24和15~0位共同构成32位的段基地址。   |

| 位域      | 名称        | 说明                                                       |
| --------- | ----------- | ---------------------------------------------------------- |
| **31~16** | 段基址 15~0 | 段基地址的低16位，与31~24和23~16位共同构成32位的段基地址。 |
| **15~0**  | 段界限 15~0 | 段限长的低16位，与19~16位共同构成20位的段限长。            |

#### LDT

​	LDT跟GDT针锋相对，LDT是本地的描述符表。按照Intel的构想，我们的任务堆栈和所有的数据表达都放到LDT中去但是实际上，几乎没有操作系统使用LDT来完成用户任务的切换。

​	原因很简单：使用LDT增加了内存管理的复杂性，每一个进程还要记得自己的LDT搁哪呢，而且，使用LDT上，切换速度不如直接将老的TSS指针压栈迅速，不用抽空访问LDT表查询自己的段。最重要的是——现代操作系统几乎不使用分段了，几乎全部转向了分页！

#### GDTR

​	所以，我们就把目光放到外面的GDTR上去！刚刚外面说，GDT等价于若干64位的描述符表的数组，所以，只需要存储GDT表的起始地址和它的大小，就完成了我们访问GDT的办法。

​	GDTR就是薄记者。它薄记了我们说的——GDT表的起始地址和它的大小。这个寄存器48位。32位起始地址和16位的大小声明，一共可以标识8192个描述符。

#### 所以，GDT是怎么使用的呢？

​	答案是——我们的CS, DS, ES, FS, GS, SS等终于要装新东西了！现在我们的段要装上我们的段选择子。段选择子跟我们的段寄存器大小一致。都是16位。

​	我们的16位被划分为这样的位域。

| 位域   | 名称     | 说明                                |
| ------ | -------- | ----------------------------------- |
| 3 ~ 15 | 段索引值 | 索引的index                         |
| 2      | TI       | 为0表达在GDT中索引，反之在LDT中索引 |
| 0 ~ 1  | RPL      | 请求的特权级                        |

​	RPL比较难理解，所拜了就是当前的请求特权级能不能配得上去请求目标的段描述符的特权级。

### A20地址线：解锁我们的更大内存访问

​	这个玩意就属于我们通向更加广阔天地的一把锁了。在x86架构的早期阶段，处理器的地址总线有20条地址线，因此理论上最多可以寻址1MB的内存。

​	然而，随着内存容量的增加，处理器在访问更大内存空间时遇到了限制。为了突破这一限制，Intel在1980年代初期引入了A20地址线。A20地址线的作用是扩展到32位的地址空间，并允许访问超过1MB的内存。

​	最初，A20地址线是被硬件硬编码的，默认处于禁用状态，这意味着只能寻址1MB内存。凡是访问大于1MB的内存都会被绕回来到从0x00000开始访问的状态。后来，通过特殊的操作系统技术和硬件改进，A20地址线得以启用，从而解决了“1MB内存限制”的问题。

​	笔者会在正文中阐述如何打开A20地址线。

## 所以，保护模式的保护，体现在哪些地方

### 选择子选择段描述符时

​	现在，我们终于可以行云流水般的谈论我们的保护模式保护在哪里了。

​	首先就是验证段选择子（我们默认在GDT中查询）：

- 我们从段中拿到段选择子。
- 先看索引值有没有超过GDTR指代的索引值的个数，超过了给你抛一个异常烟花。判断的办法是：**取出GDTR的前32位作为基地址，加上我们要访问的索引值 * 8 + 7必须小于基地址 + 界限值**（当然，我们直接比较的是地址，而不是运算索引，乘法要比除法快）
- 其次，拿到我们的索引的段描述符，根据段的身份来检查我们有没有正确的对应我们的属性，看下表：

| 段寄存器 | 代码段 (X=1) | 代码段 (X=1)    | 数据段 (X=0)    | 数据段 (X=0) |
| -------- | ------------ | --------------- | --------------- | ------------ |
|          | 只执行 (R=0) | 执行+可读 (R=1) | 只读 (R=1, W=0) | 读写 (W=1)   |
| CS       | 通过         | 通过            | 不通过          | 不通过       |
| DS       | 不通过       | 通过            | 通过            | 通过         |
| ES       | 不通过       | 通过            | 通过            | 通过         |
| FS       | 不通过       | -               | 通过            | 通过         |
| GS       | 不通过       | 通过            | 通过            | 通过         |
| SS       | 不通过       | 不通过          | 不通过          | 通过         |

- 在之后，就是检查段描述符本身是否合法，这里就是看P这个位。P在，也就是1才能被访问，否则，抛出异常

### 访问代码段和数据段

​	必须要保证我们的地址落在界限之前！就是这样。我们根据G是0还是1进行界限的放缩后得到真正的界限后，根据我们的访问地址进行比较。

> 这里是操作系统真相还原的例子

​	以栈访问为例子：32位保护模式下栈的栈顶指针是esp寄存器，栈的操作数大小是由B位决定的，我们这里假设B为1，即操作数是32位。栈段也是位于内存中，所以它也要受控于段描述符中的G位。

- 如果G为0，实际的段界限大小=描述符中的段界限。
- 如果G为1，实际的段界限大小=描述符中段界限*0x1000+0xFFF。

​	同代码段的操作数一样，用于压栈的操作数也有其长度，push指令每向栈中压入操作数时，实际上就是将esp指针减去操作数的大小（2字节或4字节）后，再将操作数复制到esp减4后的新地址。栈指针可访问的最低地址是由实际段界限决定的，但栈段最大可访问的地址是由B位决定的，我们这里B位为1，表示32位操作数，所以栈指针最大可访问地址是0xFFFFFFFF。

```
实际段界限+1≤esp-操作数大小≤ 0xFFFFFFFF
```

​	假设现在esp指针为0xFFFFE002，段描述符的G位为1，描述符中的段界限为0xFFFFD。故实际段界限为0x1000*FFFFD+0xFFF=0xFFFFDFFF。当执行 push ax,压入2字节的操作数，即 esp-2=0xFFFFE000, 新的 esp 值≥实际段界限 0xFFFFDFFF+1。如果执行 push eax,压入4字节的数据，_esp-4=0xFFFFDFFE, 小于实际段界限0xFFFFDFFF，故CPU会抛出异常。

​	由于esp只是栈段内的偏移地址，其真正物理地址还要加上段基址。假设段基址为0，故该栈段：最大可访问地址为0+0xFFFFFFFF=0xFFFFFFFF。最小可访问地址为0+0xFFFFDFFF+1=0xFFFFE000。 栈段空间大小为0xFFFFFFFF-0xFFFFE000=8KB。 

# Reference

1.  IA32手册：[Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html)，笔者下载的是1~4卷，当然，对汇编足够熟悉的朋友不妨直接下载第三卷，直接阅读系统编程
2. 《操作系统还原真相》作者: [郑钢](https://book.douban.com/search/郑钢)，[操作系统真象还原 (豆瓣)](https://book.douban.com/subject/26745156/)