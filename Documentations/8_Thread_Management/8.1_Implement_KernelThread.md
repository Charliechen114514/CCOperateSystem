# 进程子系统的构建——实现内核线程

## 前言

​	好消息！我们终于可以向更近一步迈出了！那就是构建我们的进程子系统！这就意味着，我们终于可以准备向并发任务靠近了！

## 所以，我们的执行流

​	在之前，我们的计算机只有一个处理器（现在好多了，笔者的电脑上是16个逻辑CPU！），所以，在多任务的操作系统出现之前，我们的计算机一次真的只能做一个事情，即：任务的执行都是串行的，一个任务彻底执行完成后才能开始下一个任务。 

​	毫无疑问，伴随着计算机产业的爆发，需要交给计算机做的事情越来越多了，我们希望，系统可以提高自己的响应性，至少看起来，我们的系统可以并发的做非常多的事情。

​	于是，在处理器数量不变的情况下，多任务操作系统出现了，它采用了 一种称为多道程序设计的方式，使处理器在所有任务之间来回切换，这样就 给用户一种所有任务并行运行的错觉，这称为“伪并行”，毕竟在任意时刻，处理器只会执行某一个任务，**处理器会落到哪些任务上执行，这是由操作系统中的任务调度器决定的。每一个任务都在CPU上跑一小会，到点我们就换一个。**

​	负责这个的是任务调度器，**简单来说，就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。**调度器在内核中维护一个任务表（也称进程表、线程表或调度表），然后按照一定的算法， 从任务表中选择一个任务，然后把该任务放到处理器上运行，当任务运行的时间片到期后，再从任务表中 找另外一个任务放到处理器上运行，周而复始，让任务表中的所有任务都有机会运行。正是因为有了调度器，**多任务操作系统才能得以实现，它是多任务系统的核心，它的好坏直接影响了系统的效率。** 这种伪并行的好处是降低了任务的平均响应时间，通俗点说，就是让那些执行时间短的任务不会因为 “后到”而不得不等前面“先来”的且执行时间很长的程序执行完后才能获得执行的机会，整体上“显得”快了很多。当然这和调度算法有关，**这里所说的调度算法是较为“公正”的时间片轮转算法，也称为轮询。**

​	我们对于所有的任务而言，其理想综合时间没有变化，甚至更加严谨的说是变长了。因为软件切换也需要时间。

> 笔者记得有一篇Paper探讨了任务切换时间和响应度之间的文章，但是笔者最近没空找。简单的说——任务切换是需要时间的，我们不可以无限的加大切换的频率，否则，我们的电脑只会疲惫的切换任务而不执行任务，导致响应比断崖式下跌

![image-20250301173419908](./8.1_Implement_KernelThread/image-20250301173419908.png)

​	注意到的是——我们并没有使用硬件TSS来完成这个任务。Linux等操作系统认为这不利于移植，而且管理非常的麻烦，我们这里也是采用软件TSS。**也就是我们自己模拟一套进程的上下文来实现一个进程切换。**

​	指令是具备“能动性”的数据，因此只有指令才有“执行”的能力，它相当于是动作的发出者，由它指导 处理器产生相应的行为。指令是由处理器来执行的，它引领处理器“前进”的方向，用“流”来表示处理器中程序计数器的航向，借此比喻处理器依次把此区域中的指令执行完后，所形成的像河流一样曲直不一的执行轨迹、执行路径（由顺序执行指令及跳转指令导致）。 

​	执行流对应于代码，大到可以是整个程序文件，即进程，小到可以是一个功能独立的代码块，即函数， 而线程本质上就是函数。 执行流是独立的，它的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源， 这是 Intel 处理器在硬件上规定的，其实这正是执行流的上下文环境。

​	归根揭底，任务并行这是用软件来切换任务模拟出来的 假象，处理器根本就不在乎切换任务这回事。我们没有使用架构层次的切换，我们只是自己手动的给处理器源源不断的指令——物理层次上，指令是连续的。因为处理器只知道加电后按照程序计数器中的地址不断地执行下去， 在不断执行的过程中，我们把程序计数器中的下一条指令地址所组成的执行轨迹称为程序的控制执行流。这就是我们之后要做的工作！

## 区分进程和线程

​	程序是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像。 这个事情，我相信很多人学习的时候就知道。依次来看，进程就是那些正在运行的程序，所包含的包括执行的上下文的所有环境

​	对于处理器来说**，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是处理器的执行单位，或者称为调度单位**，它们就是**线程**。也就是说，处理器看来，更关心的是内部所要求执行的代码，我们只看执行流的时候，说的更加像是线程。

​	进程比较重，是操作系统**进行资源分配的基本单位**。每个进程都有独立的内存空间，这意味着一个进程崩溃不会直接影响其他进程。进程之间的通信需要通过特定的机制，如管道、消息队列或共享内存等。由于进程拥有独立的地址空间，创建和销毁进程的开销相对较大，因为它们涉及到内存分配、资源初始化等操作。

​	线程则是进程中的一个执行单元，是CPU调度和分派的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源。线程之间的通信更加直接和高效，因为它们可以直接读写相同的内存地址。在性能方面，线程通常比进程更高效，因为它们共享内存空间，减少了上下文切换的开销。上下文切换是指CPU从一个执行单元切换到另一个执行单元的过程，这个过程需要保存和恢复执行环境。由于线程共享相同的地址空间，线程间的上下文切换比进程间的切换要快得多。然而，线程的并发控制也更加复杂，需要使用锁、信号量等同步机制来避免竞态条件和死锁。

​	我的看法是——进程原先的职责的进一步细分诞生了线程，我们的线程专心的处理执行逻辑，进程不过是更宏大的抽象的一个具体实体——即，进程包含了线程，给线程一个托付之地，给他提供一系列的资源。整体来看，这样提高了相应程度：

​	比如当进程因等待用户输入而暂时无法继续运行时，此时操作系统会把整个进程挂起，也就是将其从就绪队列中去除，这样便无法获得执行的机会，等用户输入完成，可以继续执行后，操作系统再将其加入 到就绪队列，这样调度器才会重新调度它上处理器运行。然而，并不是进程中所有的部分都依赖于用户的 输入，对于那些不依赖于用户输入的代码块，可以为其单独创建一线程来“并行”执行，这样进程的某个 执行流阻塞于用户输入时，此进程的另一线程还能运行，还能继续做其他事，相当于给进程提速了。

## 进程也有状态

​	程序在运行时，有可能因为某种情况而无法继续运行，比如某进程的功能是分析日志，它先要读取磁盘，把日志从文件系统中读入内存，之后再从内存中分析日志。访问文件系统需要经过外部设备的操作，比如硬盘，这通常比较耗时，因此在等待 IO 操作的时间内，分析日志的工作是无法进行的，**该进程无法做任何事，只能等待。当日志文件从磁盘调入到内存后，进程便准备做日志分析的工作了，之后开始运行 日志分析的代码，处理日志，直到完成。** 

​	这样看来，程序从执行到结束的整个过程中，并不是所有阶段都一直开足马力在处理器上运行，有的时候 也会由于依赖第三方等“种种无奈”的外在条件而不得不停下来，当这种情况出现时，操作系统就可以把处理器分配给其他线程使用，这样就可以充分利用处理器的宝贵资源了。 为此，操作系统把进程“执行过程”中所经历的不同阶段按状态归为几类，注意，强调的是“执行过程”，意为进程的状态描述的是进程中有关“动作”的执行流部分，即线程，而不包括静止的资源部分。 

​	把上述需要等待外界条件的状态称为“阻塞态”，把外界条件成立时，进程可以随时准备运行的状态称为“就绪态”，把正在处理器上运行的进程的状态称为“运行态”。 只要“条件”成立，进程的状态就可以改变，通常这种状态的转变是由操作系统的调度器及相关代码负责的，因为只有它们才知道“条件”是否满足了，如图9-5 所示。进程的状态表示进程从出生到死亡的一系列所处的阶段，操作系统的调度器 可以利用它更加高效地管理进程调度。 

​	以上虽然是以进程举例，但实际上已经和大伙儿强调过多次了，调度器的调度单位是执行流，“状态”描述的也是执行流，而“状态”又主要是给调度器用的，因此“状态”是对所有执行流而言的概念，这里所说的进程状态其实就是指单线程进程中线程的状态，归根结底，状态是描述线程的。

## 进程的身份证：PCB结构

所以问题来了：

1. 要加载一个任务上处理器运行，任务由哪来？也就是说，调度器从哪里才能找到该任务？ 
2. 即使找到了任务，任务要在系统中运行，其所需要的资源从哪里获得？ 
3. 即使任务已经变成进程运行了，此进程应该运行多久呢？总不能让其独占处理器吧。 
4. 即使知道何时将其换下处理器，那当前进程所使用的这一套资源（寄存器内容）应该存在哪里？ 
5. 进程被换下的原因是什么？下次调度器还能把它换上处理器运行吗？ 
6. 前面都说过了，进程独享地址空间，它的地址空间在哪里？

![image-20250301174753139](./8.1_Implement_KernelThread/image-20250301174753139.png)

![image-20250301174818409](./8.1_Implement_KernelThread/image-20250301174818409.png)

​	来看看PCB！Process Control Block! 这就是我们说的进程身份证。我们一个一个回答上面的问题。

​	之前我们说过，物理上，处理器不关心我们的任务执行的代码到底是不是一个线程的，但是在逻辑层面上，我们不得不关心！我们使用PCB来表示一个进程。

​	PCB 没有具体的格式，其实际格式取决于操作系统的功能复杂度，以上只是列出了基本该有的内容。 

​	PCB 中包含“进程状态”，它解决了上面第5个问题，比如进程状态为阻塞态，下次就不能把它调度到处理器上了。“时间片”解决上面第 3 个问题，当时间片的值为 0 时，表示该进程此次的运行时间到期了，踢下 CPU ！

​	“页表”解决了上面第6 个问题，它代表进程的地址空间。

​	“寄存器映像”是用来解决上面第4 个问题的，即保存进程的“现场”，进程在处理器上运行时，所有寄存器的值都将保存到此处。一般情况下它位于 PCB 的顶端，不过位置也不固定，具体位置取决于 0 级 栈指针的位置，总之它会在 PCB 中上下滑动。其实第 4 个问题解决了，第 2 个问题也就一同搞定了，再从 PCB 中把寄存器映像加载到寄存器中就行了。 

​	目前只剩下第1 个问题没有解决了，其实，要解决此问题，就是要单独维护一个进程表，将所有的PCB结构加载到此表中，由调度器直接在进程表中找相应进程的 PCB，从而获取到对应进程的信息，将其寄 存器映像加载到处理器后，新进程就开始运行了。 

​	当然，还有一个叫做栈的东西：进程使用的栈也属于 PCB 的一部分， 不过此栈是进程所使用的0 特权级下内核栈（并不是3 特权级下的用户栈）。栈在PCB 中，这听上去有点 不可思议，但细想一下还是觉得合理的。和进程相关的所有资源都应该集中放在一起，这样才方便管理。所以，PCB 一般都很大，通常以页为单位，咱们系统比较小， PCB 只占一页。顺便说一句，上面所说的“寄存器映像”的位置并不固定，原因就是“寄存器映像”存 储到内核栈中，通常情况下进程或线程被中断时，处理器自动在 TSS 中获取内核栈指针，这通常是 PCB 的顶端，因此通常情况下“寄存器映像”位于 PCB 的顶端。但有时候进程或线程的上下文，也就是“寄 存器映像”，并不是在中断发生时保存到栈中的，而是在内核态下工作时，栈指针已经发生了变化时才向 栈中保存“寄存器映像”，比如线程主动让出处理器，这时候就得保存线程的现场，此时“寄存器映像” 必然就不在 PCB 顶端了。提醒一下，内核态未必都是关中断的状态，可以在开中断下执行内核代码，否 则就不会接收时钟中断，进而就不会调用调度器，也就无法进行任务调度了

​	鉴于“寄存器映像”的位置并不固定，我们在 PCB 中还要维护一个“栈指针”成员，它记 录 0 级栈栈顶的位置，借此找到进程或线程的“寄存器映像”。 

## 实现线程的两种方式——内核或用户进程 

​	线程的实现就有两种 方式，要么由操作系统原生支持，用户进程通过系统调用使用线程，要么操作系统不支持线程，由进程自 己想办法解决。因此，线程要么在 0 特权级的内核空间中实现，要么在 3 特权级的用户空间实现

​	线程仅仅是个执行流，在用户空间，还是在内核空间实现它，最大的区别就是线程表在哪里，由谁来 调度它上处理器。如果线程在用户空间中实现，线程表就在用户进程中，用户进程就要专门写个线程用作 线程调度器，由它来调度进程内部的其他线程。如果线程在内核空间中实现，线程表就在内核中，该线程就 会由操作系统的调度器统一调度，无论该线程属于内核，还是用户进程。 

​	对于内核线程：

1. 内核线程可以直接映射到CPU的核心上，因此多个线程可以真正并行执行（在多核处理器上）。这使得内核线程非常适合需要高并发和高性能的应用场景。
2. 由于内核线程由操作系统直接管理，操作系统可以更有效地将线程分配到不同的CPU核心上，充分利用多核处理器的计算能力。
3. 如果一个内核线程执行了阻塞操作（如I/O操作），内核可以调度其他线程继续执行，而不会阻塞整个进程。这使得内核线程在处理I/O密集型任务时表现更好。
4. 内核线程由操作系统直接管理，因此可以充分利用操作系统提供的功能，如优先级调度、资源管理和安全性控制。
5. 内核线程之间的错误通常不会相互影响，因为操作系统会为每个线程提供独立的上下文和资源管理。
6. 内核线程的创建、销毁和上下文切换需要内核的介入，这会导致较高的开销。每次线程切换都需要从用户态切换到内核态，增加了额外的性能损耗。
7. 内核线程的实现和调度逻辑较为复杂，需要操作系统的支持。开发者对线程的控制能力较弱，无法直接优化线程的行为。
8. 每个内核线程都需要占用一定的内核资源（如栈空间和线程控制块），因此创建大量内核线程可能会导致系统资源耗尽。
9. 内核线程的实现依赖于操作系统的支持，因此在不同操作系统之间的可移植性较差。

对于用户线程

1. 用户线程的创建、销毁和上下文切换完全在用户空间完成，不需要内核的介入，因此开销较低。线程切换只需要保存和恢复用户空间的寄存器状态，速度更快。
2. 用户线程的调度策略可以由开发者自定义，而不受操作系统的限制。这使得用户线程非常适合需要特定调度策略的应用场景。
3. 用户线程的实现通常基于标准的线程库，因此在不同操作系统之间的可移植性较好。
4. 用户线程不需要占用内核资源，因此可以创建大量的线程而不会导致系统资源耗尽。
5. 用户线程非常适合需要大量并发线程的任务（如网络服务器），因为它们的创建和切换开销较低。
6. 用户线程无法直接映射到CPU核心上，因此无法真正实现并行执行（除非与内核线程结合使用）。在多核处理器上，用户线程的性能优势有限。
7. 如果一个用户线程执行了阻塞操作（如I/O操作），整个进程都会被阻塞，因为操作系统并不知道用户线程的存在。这会导致其他用户线程无法继续执行。
8. 用户线程的调度完全由用户空间的线程库管理，无法利用操作系统提供的优先级调度和资源管理功能。
9. 用户线程的实现需要开发者自行管理线程的调度和同步，增加了开发的复杂性。
10. 用户线程无法直接利用操作系统提供的某些功能（如信号处理、CPU亲和性等），这可能会限制其应用场景。





![image-20250301175425014](./8.1_Implement_KernelThread/image-20250301175425014.png)

​	看看这个图！说的很明白了，也就是说，后者的实现更加干净利落些。所以笔者决定使用后者的方式！